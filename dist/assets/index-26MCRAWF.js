(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const h of document.querySelectorAll('link[rel="modulepreload"]'))l(h);new MutationObserver(h=>{for(const d of h)if(d.type==="childList")for(const m of d.addedNodes)m.tagName==="LINK"&&m.rel==="modulepreload"&&l(m)}).observe(document,{childList:!0,subtree:!0});function c(h){const d={};return h.integrity&&(d.integrity=h.integrity),h.referrerPolicy&&(d.referrerPolicy=h.referrerPolicy),h.crossOrigin==="use-credentials"?d.credentials="include":h.crossOrigin==="anonymous"?d.credentials="omit":d.credentials="same-origin",d}function l(h){if(h.ep)return;h.ep=!0;const d=c(h);fetch(h.href,d)}})();var we,R,Ze,te,Ne,ei,Se,ii,je,Fe,Ie,ni,oe={},ti=[],ui=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,Ae=Array.isArray;function ee(n,t){for(var c in t)n[c]=t[c];return n}function Re(n){n&&n.parentNode&&n.parentNode.removeChild(n)}function mi(n,t,c){var l,h,d,m={};for(d in t)d=="key"?l=t[d]:d=="ref"?h=t[d]:m[d]=t[d];if(arguments.length>2&&(m.children=arguments.length>3?we.call(arguments,2):c),typeof n=="function"&&n.defaultProps!=null)for(d in n.defaultProps)m[d]===void 0&&(m[d]=n.defaultProps[d]);return fe(n,m,l,h,null)}function fe(n,t,c,l,h){var d={type:n,props:t,key:c,ref:l,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:h??++Ze,__i:-1,__u:0};return h==null&&R.vnode!=null&&R.vnode(d),d}function M(n){return n.children}function ge(n,t){this.props=n,this.context=t}function se(n,t){if(t==null)return n.__?se(n.__,n.__i+1):null;for(var c;t<n.__k.length;t++)if((c=n.__k[t])!=null&&c.__e!=null)return c.__e;return typeof n.type=="function"?se(n):null}function ri(n){var t,c;if((n=n.__)!=null&&n.__c!=null){for(n.__e=n.__c.base=null,t=0;t<n.__k.length;t++)if((c=n.__k[t])!=null&&c.__e!=null){n.__e=n.__c.base=c.__e;break}return ri(n)}}function We(n){(!n.__d&&(n.__d=!0)&&te.push(n)&&!ve.__r++||Ne!==R.debounceRendering)&&((Ne=R.debounceRendering)||ei)(ve)}function ve(){var n,t,c,l,h,d,m,v;for(te.sort(Se);n=te.shift();)n.__d&&(t=te.length,l=void 0,d=(h=(c=n).__v).__e,m=[],v=[],c.__P&&((l=ee({},h)).__v=h.__v+1,R.vnode&&R.vnode(l),Le(c.__P,l,h,c.__n,c.__P.namespaceURI,32&h.__u?[d]:null,m,d??se(h),!!(32&h.__u),v),l.__v=h.__v,l.__.__k[l.__i]=l,oi(m,l,v),l.__e!=d&&ri(l)),te.length>t&&te.sort(Se));ve.__r=0}function ci(n,t,c,l,h,d,m,v,y,_,w){var p,C,k,A,B,E,q=l&&l.__k||ti,S=t.length;for(y=fi(c,t,q,y,S),p=0;p<S;p++)(k=c.__k[p])!=null&&(C=k.__i===-1?oe:q[k.__i]||oe,k.__i=p,E=Le(n,k,C,h,d,m,v,y,_,w),A=k.__e,k.ref&&C.ref!=k.ref&&(C.ref&&ze(C.ref,null,k),w.push(k.ref,k.__c||A,k)),B==null&&A!=null&&(B=A),4&k.__u||C.__k===k.__k?y=si(k,y,n):typeof k.type=="function"&&E!==void 0?y=E:A&&(y=A.nextSibling),k.__u&=-7);return c.__e=B,y}function fi(n,t,c,l,h){var d,m,v,y,_,w=c.length,p=w,C=0;for(n.__k=new Array(h),d=0;d<h;d++)(m=t[d])!=null&&typeof m!="boolean"&&typeof m!="function"?(y=d+C,(m=n.__k[d]=typeof m=="string"||typeof m=="number"||typeof m=="bigint"||m.constructor==String?fe(null,m,null,null,null):Ae(m)?fe(M,{children:m},null,null,null):m.constructor===void 0&&m.__b>0?fe(m.type,m.props,m.key,m.ref?m.ref:null,m.__v):m).__=n,m.__b=n.__b+1,v=null,(_=m.__i=gi(m,c,y,p))!==-1&&(p--,(v=c[_])&&(v.__u|=2)),v==null||v.__v===null?(_==-1&&C--,typeof m.type!="function"&&(m.__u|=4)):_!=y&&(_==y-1?C--:_==y+1?C++:(_>y?C--:C++,m.__u|=4))):n.__k[d]=null;if(p)for(d=0;d<w;d++)(v=c[d])!=null&&!(2&v.__u)&&(v.__e==l&&(l=se(v)),li(v,v));return l}function si(n,t,c){var l,h;if(typeof n.type=="function"){for(l=n.__k,h=0;l&&h<l.length;h++)l[h]&&(l[h].__=n,t=si(l[h],t,c));return t}n.__e!=t&&(t&&n.type&&!c.contains(t)&&(t=se(n)),c.insertBefore(n.__e,t||null),t=n.__e);do t=t&&t.nextSibling;while(t!=null&&t.nodeType==8);return t}function gi(n,t,c,l){var h,d,m=n.key,v=n.type,y=t[c];if(y===null||y&&m==y.key&&v===y.type&&!(2&y.__u))return c;if(l>(y!=null&&!(2&y.__u)?1:0))for(h=c-1,d=c+1;h>=0||d<t.length;){if(h>=0){if((y=t[h])&&!(2&y.__u)&&m==y.key&&v===y.type)return h;h--}if(d<t.length){if((y=t[d])&&!(2&y.__u)&&m==y.key&&v===y.type)return d;d++}}return-1}function Be(n,t,c){t[0]=="-"?n.setProperty(t,c??""):n[t]=c==null?"":typeof c!="number"||ui.test(t)?c:c+"px"}function ae(n,t,c,l,h){var d;e:if(t=="style")if(typeof c=="string")n.style.cssText=c;else{if(typeof l=="string"&&(n.style.cssText=l=""),l)for(t in l)c&&t in c||Be(n.style,t,"");if(c)for(t in c)l&&c[t]===l[t]||Be(n.style,t,c[t])}else if(t[0]=="o"&&t[1]=="n")d=t!=(t=t.replace(ii,"$1")),t=t.toLowerCase()in n||t=="onFocusOut"||t=="onFocusIn"?t.toLowerCase().slice(2):t.slice(2),n.l||(n.l={}),n.l[t+d]=c,c?l?c.u=l.u:(c.u=je,n.addEventListener(t,d?Ie:Fe,d)):n.removeEventListener(t,d?Ie:Fe,d);else{if(h=="http://www.w3.org/2000/svg")t=t.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(t!="width"&&t!="height"&&t!="href"&&t!="list"&&t!="form"&&t!="tabIndex"&&t!="download"&&t!="rowSpan"&&t!="colSpan"&&t!="role"&&t!="popover"&&t in n)try{n[t]=c??"";break e}catch{}typeof c=="function"||(c==null||c===!1&&t[4]!="-"?n.removeAttribute(t):n.setAttribute(t,t=="popover"&&c==1?"":c))}}function Oe(n){return function(t){if(this.l){var c=this.l[t.type+n];if(t.t==null)t.t=je++;else if(t.t<c.u)return;return c(R.event?R.event(t):t)}}}function Le(n,t,c,l,h,d,m,v,y,_){var w,p,C,k,A,B,E,q,S,N,$,P,F,I,W,x,a,z=t.type;if(t.constructor!==void 0)return null;128&c.__u&&(y=!!(32&c.__u),d=[v=t.__e=c.__e]),(w=R.__b)&&w(t);e:if(typeof z=="function")try{if(q=t.props,S="prototype"in z&&z.prototype.render,N=(w=z.contextType)&&l[w.__c],$=w?N?N.props.value:w.__:l,c.__c?E=(p=t.__c=c.__c).__=p.__E:(S?t.__c=p=new z(q,$):(t.__c=p=new ge(q,$),p.constructor=z,p.render=vi),N&&N.sub(p),p.props=q,p.state||(p.state={}),p.context=$,p.__n=l,C=p.__d=!0,p.__h=[],p._sb=[]),S&&p.__s==null&&(p.__s=p.state),S&&z.getDerivedStateFromProps!=null&&(p.__s==p.state&&(p.__s=ee({},p.__s)),ee(p.__s,z.getDerivedStateFromProps(q,p.__s))),k=p.props,A=p.state,p.__v=t,C)S&&z.getDerivedStateFromProps==null&&p.componentWillMount!=null&&p.componentWillMount(),S&&p.componentDidMount!=null&&p.__h.push(p.componentDidMount);else{if(S&&z.getDerivedStateFromProps==null&&q!==k&&p.componentWillReceiveProps!=null&&p.componentWillReceiveProps(q,$),!p.__e&&(p.shouldComponentUpdate!=null&&p.shouldComponentUpdate(q,p.__s,$)===!1||t.__v==c.__v)){for(t.__v!=c.__v&&(p.props=q,p.state=p.__s,p.__d=!1),t.__e=c.__e,t.__k=c.__k,t.__k.some(function(U){U&&(U.__=t)}),P=0;P<p._sb.length;P++)p.__h.push(p._sb[P]);p._sb=[],p.__h.length&&m.push(p);break e}p.componentWillUpdate!=null&&p.componentWillUpdate(q,p.__s,$),S&&p.componentDidUpdate!=null&&p.__h.push(function(){p.componentDidUpdate(k,A,B)})}if(p.context=$,p.props=q,p.__P=n,p.__e=!1,F=R.__r,I=0,S){for(p.state=p.__s,p.__d=!1,F&&F(t),w=p.render(p.props,p.state,p.context),W=0;W<p._sb.length;W++)p.__h.push(p._sb[W]);p._sb=[]}else do p.__d=!1,F&&F(t),w=p.render(p.props,p.state,p.context),p.state=p.__s;while(p.__d&&++I<25);p.state=p.__s,p.getChildContext!=null&&(l=ee(ee({},l),p.getChildContext())),S&&!C&&p.getSnapshotBeforeUpdate!=null&&(B=p.getSnapshotBeforeUpdate(k,A)),v=ci(n,Ae(x=w!=null&&w.type===M&&w.key==null?w.props.children:w)?x:[x],t,c,l,h,d,m,v,y,_),p.base=t.__e,t.__u&=-161,p.__h.length&&m.push(p),E&&(p.__E=p.__=null)}catch(U){if(t.__v=null,y||d!=null)if(U.then){for(t.__u|=y?160:128;v&&v.nodeType==8&&v.nextSibling;)v=v.nextSibling;d[d.indexOf(v)]=null,t.__e=v}else for(a=d.length;a--;)Re(d[a]);else t.__e=c.__e,t.__k=c.__k;R.__e(U,t,c)}else d==null&&t.__v==c.__v?(t.__k=c.__k,t.__e=c.__e):v=t.__e=_i(c.__e,t,c,l,h,d,m,y,_);return(w=R.diffed)&&w(t),128&t.__u?void 0:v}function oi(n,t,c){for(var l=0;l<c.length;l++)ze(c[l],c[++l],c[++l]);R.__c&&R.__c(t,n),n.some(function(h){try{n=h.__h,h.__h=[],n.some(function(d){d.call(h)})}catch(d){R.__e(d,h.__v)}})}function _i(n,t,c,l,h,d,m,v,y){var _,w,p,C,k,A,B,E=c.props,q=t.props,S=t.type;if(S=="svg"?h="http://www.w3.org/2000/svg":S=="math"?h="http://www.w3.org/1998/Math/MathML":h||(h="http://www.w3.org/1999/xhtml"),d!=null){for(_=0;_<d.length;_++)if((k=d[_])&&"setAttribute"in k==!!S&&(S?k.localName==S:k.nodeType==3)){n=k,d[_]=null;break}}if(n==null){if(S==null)return document.createTextNode(q);n=document.createElementNS(h,S,q.is&&q),v&&(R.__m&&R.__m(t,d),v=!1),d=null}if(S===null)E===q||v&&n.data===q||(n.data=q);else{if(d=d&&we.call(n.childNodes),E=c.props||oe,!v&&d!=null)for(E={},_=0;_<n.attributes.length;_++)E[(k=n.attributes[_]).name]=k.value;for(_ in E)if(k=E[_],_!="children"){if(_=="dangerouslySetInnerHTML")p=k;else if(!(_ in q)){if(_=="value"&&"defaultValue"in q||_=="checked"&&"defaultChecked"in q)continue;ae(n,_,null,k,h)}}for(_ in q)k=q[_],_=="children"?C=k:_=="dangerouslySetInnerHTML"?w=k:_=="value"?A=k:_=="checked"?B=k:v&&typeof k!="function"||E[_]===k||ae(n,_,k,E[_],h);if(w)v||p&&(w.__html===p.__html||w.__html===n.innerHTML)||(n.innerHTML=w.__html),t.__k=[];else if(p&&(n.innerHTML=""),ci(n,Ae(C)?C:[C],t,c,l,S=="foreignObject"?"http://www.w3.org/1999/xhtml":h,d,m,d?d[0]:c.__k&&se(c,0),v,y),d!=null)for(_=d.length;_--;)Re(d[_]);v||(_="value",S=="progress"&&A==null?n.removeAttribute("value"):A!==void 0&&(A!==n[_]||S=="progress"&&!A||S=="option"&&A!==E[_])&&ae(n,_,A,E[_],h),_="checked",B!==void 0&&B!==n[_]&&ae(n,_,B,E[_],h))}return n}function ze(n,t,c){try{if(typeof n=="function"){var l=typeof n.__u=="function";l&&n.__u(),l&&t==null||(n.__u=n(t))}else n.current=t}catch(h){R.__e(h,c)}}function li(n,t,c){var l,h;if(R.unmount&&R.unmount(n),(l=n.ref)&&(l.current&&l.current!==n.__e||ze(l,null,t)),(l=n.__c)!=null){if(l.componentWillUnmount)try{l.componentWillUnmount()}catch(d){R.__e(d,t)}l.base=l.__P=null}if(l=n.__k)for(h=0;h<l.length;h++)l[h]&&li(l[h],t,c||typeof n.type!="function");c||Re(n.__e),n.__c=n.__=n.__e=void 0}function vi(n,t,c){return this.constructor(n,c)}function yi(n,t,c){var l,h,d,m;t==document&&(t=document.documentElement),R.__&&R.__(n,t),h=(l=typeof c=="function")?null:t.__k,d=[],m=[],Le(t,n=(!l&&c||t).__k=mi(M,null,[n]),h||oe,oe,t.namespaceURI,!l&&c?[c]:h?null:t.firstChild?we.call(t.childNodes):null,d,!l&&c?c:h?h.__e:t.firstChild,l,m),oi(d,n,m)}function hi(n,t){var c={__c:t="__cC"+ni++,__:n,Consumer:function(l,h){return l.children(h)},Provider:function(l){var h,d;return this.getChildContext||(h=new Set,(d={})[t]=this,this.getChildContext=function(){return d},this.componentWillUnmount=function(){h=null},this.shouldComponentUpdate=function(m){this.props.value!==m.value&&h.forEach(function(v){v.__e=!0,We(v)})},this.sub=function(m){h.add(m);var v=m.componentWillUnmount;m.componentWillUnmount=function(){h&&h.delete(m),v&&v.call(m)}}),l.children}};return c.Provider.__=c.Consumer.contextType=c}we=ti.slice,R={__e:function(n,t,c,l){for(var h,d,m;t=t.__;)if((h=t.__c)&&!h.__)try{if((d=h.constructor)&&d.getDerivedStateFromError!=null&&(h.setState(d.getDerivedStateFromError(n)),m=h.__d),h.componentDidCatch!=null&&(h.componentDidCatch(n,l||{}),m=h.__d),m)return h.__E=h}catch(v){n=v}throw n}},Ze=0,ge.prototype.setState=function(n,t){var c;c=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=ee({},this.state),typeof n=="function"&&(n=n(ee({},c),this.props)),n&&ee(c,n),n!=null&&this.__v&&(t&&this._sb.push(t),We(this))},ge.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),We(this))},ge.prototype.render=M,te=[],ei=typeof Promise=="function"?Promise.prototype.then.bind(Promise.resolve()):setTimeout,Se=function(n,t){return n.__v.__b-t.__v.__b},ve.__r=0,ii=/(PointerCapture)$|Capture$/i,je=0,Fe=Oe(!1),Ie=Oe(!0),ni=0;var bi=0;function e(n,t,c,l,h,d){t||(t={});var m,v,y=t;"ref"in t&&(m=t.ref,delete t.ref);var _={type:n,props:y,key:c,ref:m,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:--bi,__i:-1,__u:0,__source:h,__self:d};if(typeof n=="function"&&(m=n.defaultProps))for(v in m)y[v]===void 0&&(y[v]=m[v]);return R.vnode&&R.vnode(_),_}function pe(n){return e("a",{href:`#${n.href}`,children:n.children})}var le,H,Pe,Ue,Me=0,di=[],O=R,Ge=O.__b,De=O.__r,Ve=O.diffed,Qe=O.__c,Je=O.unmount,Ye=O.__;function He(n,t){O.__h&&O.__h(H,n,Me||t),Me=0;var c=H.__H||(H.__H={__:[],__h:[]});return n>=c.__.length&&c.__.push({}),c.__[n]}function V(n){return Me=1,wi(pi,n)}function wi(n,t,c){var l=He(le++,2);if(l.t=n,!l.__c&&(l.__=[pi(void 0,t),function(v){var y=l.__N?l.__N[0]:l.__[0],_=l.t(y,v);y!==_&&(l.__N=[_,l.__[1]],l.__c.setState({}))}],l.__c=H,!H.u)){var h=function(v,y,_){if(!l.__c.__H)return!0;var w=l.__c.__H.__.filter(function(C){return!!C.__c});if(w.every(function(C){return!C.__N}))return!d||d.call(this,v,y,_);var p=l.__c.props!==v;return w.forEach(function(C){if(C.__N){var k=C.__[0];C.__=C.__N,C.__N=void 0,k!==C.__[0]&&(p=!0)}}),d&&d.call(this,v,y,_)||p};H.u=!0;var d=H.shouldComponentUpdate,m=H.componentWillUpdate;H.componentWillUpdate=function(v,y,_){if(this.__e){var w=d;d=void 0,h(v,y,_),d=w}m&&m.call(this,v,y,_)},H.shouldComponentUpdate=h}return l.__N||l.__}function ki(n,t){var c=He(le++,7);return Pi(c.__H,t)&&(c.__=n(),c.__H=t,c.__h=n),c.__}function ai(n){var t=H.context[n.__c],c=He(le++,9);return c.c=n,t?(c.__==null&&(c.__=!0,t.sub(H)),t.props.value):n.__}function xi(){for(var n;n=di.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(_e),n.__H.__h.forEach($e),n.__H.__h=[]}catch(t){n.__H.__h=[],O.__e(t,n.__v)}}O.__b=function(n){H=null,Ge&&Ge(n)},O.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),Ye&&Ye(n,t)},O.__r=function(n){De&&De(n),le=0;var t=(H=n.__c).__H;t&&(Pe===H?(t.__h=[],H.__h=[],t.__.forEach(function(c){c.__N&&(c.__=c.__N),c.i=c.__N=void 0})):(t.__h.forEach(_e),t.__h.forEach($e),t.__h=[],le=0)),Pe=H},O.diffed=function(n){Ve&&Ve(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(di.push(t)!==1&&Ue===O.requestAnimationFrame||((Ue=O.requestAnimationFrame)||Ci)(xi)),t.__H.__.forEach(function(c){c.i&&(c.__H=c.i),c.i=void 0})),Pe=H=null},O.__c=function(n,t){t.some(function(c){try{c.__h.forEach(_e),c.__h=c.__h.filter(function(l){return!l.__||$e(l)})}catch(l){t.some(function(h){h.__h&&(h.__h=[])}),t=[],O.__e(l,c.__v)}}),Qe&&Qe(n,t)},O.unmount=function(n){Je&&Je(n);var t,c=n.__c;c&&c.__H&&(c.__H.__.forEach(function(l){try{_e(l)}catch(h){t=h}}),c.__H=void 0,t&&O.__e(t,c.__v))};var Ke=typeof requestAnimationFrame=="function";function Ci(n){var t,c=function(){clearTimeout(l),Ke&&cancelAnimationFrame(t),setTimeout(n)},l=setTimeout(c,100);Ke&&(t=requestAnimationFrame(c))}function _e(n){var t=H,c=n.__c;typeof c=="function"&&(n.__c=void 0,c()),H=t}function $e(n){var t=H;n.__c=n.__(),H=t}function Pi(n,t){return!n||n.length!==t.length||t.some(function(c,l){return c!==n[l]})}function pi(n,t){return typeof t=="function"?t(n):t}function Y(n){const[t,c]=V(!1);return[t,()=>{c(!0),n&&n.on()},()=>{c(!1),n&&n.off()}]}const qi={delta:"δ",epsilon:"ε",zeta:"ζ",kappa:"κ",mu:"μ",xi:"ξ",tau:"𝜏"},o={operators:{equals:"=",precedes:"≺",less_than:"<",much_less_than:"≪",less_than_equal:"≤",greater_than:">",greater_than_equal:"≥",cross:"⨉",prime:"′",approx:"≈",absolute:"|",angle:{left:"⟨",right:"⟩"},paren:{left:"(",right:")"},arrows:{right:{single:"→",not_single:"↛",double:"⇒",thick:"➡"}}},letters:{capital:{a:{monospace:"𝙰"},b:{monospace:"𝙱"}}},greek:qi};function ie(n){return Object.entries(n).filter(([t,c])=>c).map(([t,c])=>t).join(" ")}const Xe=hi(!0);function re(n){return ai(Xe)?e("math",{display:n.display,children:e(Xe.Provider,{value:!1,children:n.children})}):n.children}function he(n){return n.view==="notation"?n.notation:n.description}function u(n){const[t,c]=V("notation"),l=m=>v=>{n.description&&(v.stopPropagation(),c(m))},h=m=>{n.source&&(m.stopPropagation(),n.source[1]())},d=m=>{n.source&&(m.stopPropagation(),n.source[2]())};return e(re,{display:n.display,children:e(he,{view:t,notation:e("mrow",{title:n.description,onClick:l("description"),onMouseOver:h,onMouseOut:d,children:n.children}),description:e("mtext",{class:"description",onClick:l("notation"),onMouseOver:h,onMouseOut:d,children:n.description})})})}function i(n){const[t,c]=V("notation"),l=m=>{if(n.description)return v=>{v.stopPropagation(),c(m)}},h=ie({[n.class??""]:!0,description:t==="description"});let d=null;return t==="notation"?d=e("mi",{class:h,title:n.description,onClick:l("description"),children:n.children}):d=e("mtext",{class:h,onClick:l("notation"),children:n.description}),e(re,{children:d})}function r(n){const[t,c]=V("notation"),l=d=>{if(n.description)return m=>{m.stopPropagation(),c(d)}};let h=null;return t==="notation"?h=e("mo",{title:n.description,onClick:l("description"),children:n.children}):h=e("mtext",{class:"description",onClick:l("notation"),children:n.description}),e(re,{children:h})}function g(n){return e("mn",{title:n.description,children:n.value})}function s(n){const[t,c]=V("notation"),l=m=>{if(n.description)return v=>{v.stopPropagation(),c(m)}},h=m=>{n.source&&(m.stopPropagation(),n.source[1]())},d=m=>{n.source&&(m.stopPropagation(),n.source[2]())};return e(re,{children:e(he,{view:t,notation:e("msub",{title:n.description,onClick:l("description"),onMouseOver:h,onMouseOut:d,children:n.children}),description:e("mtext",{class:"description",onClick:l("notation"),onMouseOver:h,onMouseOut:d,children:n.description})})})}function Ei(n){const[t,c]=V("notation"),l=h=>{if(n.description)return d=>{d.stopPropagation(),c(h)}};return e(re,{children:e(he,{view:t,notation:e("msup",{title:n.description,onClick:l("description"),children:n.children}),description:e("mtext",{class:"description",onClick:l("notation"),children:n.description})})})}function ne(n){const[t,c]=V("notation"),l=h=>{if(n.description)return d=>{d.stopPropagation(),c(h)}};return e(re,{children:e(he,{view:t,notation:e("mfrac",{title:n.description,onClick:l("description"),children:n.children}),description:e("mtext",{class:"description",onClick:l("notation"),children:n.description})})})}function Ti(n){const[t,c]=V("notation"),l=h=>{if(n.description)return d=>{d.stopPropagation(),c(h)}};return e(re,{children:e(he,{view:t,notation:e("munder",{title:n.description,onClick:l("description"),children:n.children}),description:e("mtext",{class:"description",onClick:l("notation"),children:n.description})})})}class ye{constructor(){this.nodes=[],this._moveBuilder={absolute:t=>(this.nodes.push({type:"move-absolute",point:t}),this),relative:t=>(this.nodes.push({type:"move-relative",direction:t}),this)},this._lineBuilder={absolute:t=>(this.nodes.push({type:"line-absolute",point:t}),this),relative:t=>(this.nodes.push({type:"line-relative",direction:t}),this)},this._quadraticBuilder={absolute:(t,c)=>(this.nodes.push({type:"quadratic-absolute",control:t,end:c}),this)},this._cubicBuilder={absolute:(t,c,l)=>(this.nodes.push({type:"cubic-absolute",startControl:t,endControl:c,end:l}),this)}}get move(){return this._moveBuilder}get line(){return this._lineBuilder}get quadratic(){return this._quadraticBuilder}get cubic(){return this._cubicBuilder}toString(){return this.nodes.map(t=>{switch(t.type){case"line-absolute":return`L ${t.point.x} ${t.point.y}`;case"line-relative":return`l ${t.direction.dx} ${t.direction.dy}`;case"move-absolute":return`M ${t.point.x} ${t.point.y}`;case"move-relative":return`m ${t.direction.dx} ${t.direction.dy}`;case"quadratic-absolute":return`Q ${t.control.x}, ${t.control.x} ${t.end.x} ${t.end.y}`;case"cubic-absolute":return`C ${t.startControl.x}, ${t.startControl.y} ${t.endControl.x},${t.endControl.y} ${t.end.x},${t.end.y}`;default:throw new Error("Unknown node type")}}).join(" ")}}function be(n,t){return{start:n,end:t}}function Si(n,t,c,l){const h=[],d=[];d.push([c]);for(let m=1;m<=100;m++){const v=d.pop();if(v===void 0)break;if(l(v[0],t)){h.push(v);continue}const y=n.filter(_=>l(_.end,v[0])).map(_=>_.start);for(const _ of y)d.push([_,...v])}return h}class L{constructor(t,c){this.x=t,this.y=c}minus(t){return new Z(this.x-t.x,this.y-t.y)}add(t){return new L(this.x+t.dx,this.y+t.dy)}equals(t,c){const l=(h,d,m)=>Math.abs(h-d)<=m;return l(this.x,t.x,c)&&l(this.y,t.y,c)}asDirection(){return new Z(this.x,this.y)}}class Z{constructor(t,c){this.dx=t,this.dy=c}scale(t){return new Z(t*this.dx,t*this.dy)}get length(){return Math.sqrt(Math.pow(this.dx,2)+Math.pow(this.dy,2))}get angle(){return Math.atan2(this.dy,this.dx)}rotate(t){const c=this.dx*Math.cos(t)-this.dy*Math.sin(t),l=this.dx*Math.sin(t)+this.dy*Math.cos(t);return new Z(c,l)}add(t){return new Z(this.dx+t.dx,this.dy+t.dy)}negate(){return new Z(-this.dx,-this.dy)}}function ue(n){return e("line",{class:n.class,x1:n.start.x,y1:n.start.y,x2:n.end.x,y2:n.end.y})}function Fi(n){const t=n.points.map(c=>`${c.x},${c.y}`).join(" ");return e("polyline",{class:n.class,points:t})}function Ii(n,t){const c=t.minus(n),l=c.length,h=c.angle,d=_=>n.add(_.asDirection().rotate(h));function m(_,w){const p=new ye,C=Math.round(_/w),k=_/C,A=new Z(1,0),B=new Z(0,1);let E=new L(0,0);p.move.absolute(E);let q=A.scale(k/2),S=B.scale(2),N=E.add(q),$=E.add(q.add(S)),P=E.add(A.scale(k).add(S));p.cubic.absolute(N,$,P);for(let F=1;F<C-2;F++)S=S.negate(),E=P,N=E.add(q),$=E.add(q.add(S)),P=E.add(A.scale(k).add(S)),p.cubic.absolute(N,$,P);return E=P,N=E.add(q),$=new L(E.x+k/2,0),P=new L(_,0),p.cubic.absolute(N,$,P),p}const v=m(l,5),y=new ye;return v.nodes.forEach(_=>{_.type==="move-absolute"?y.move.absolute(d(_.point)):_.type==="cubic-absolute"&&y.cubic.absolute(d(_.startControl),d(_.endControl),d(_.end))}),y.toString()}function Wi(){const[n,t]=V(),[c,l]=V();return[be(n,c),h=>{t(h)},h=>{l(h)}]}function Mi(n,t){return n<1?[]:n===1?[t/2]:n===2?[0,t]:[...new Array(n).keys()].map((c,l)=>l*t/(n-1))}function $i(n,t,c){const l=t-n;return n+c*l}const ji=hi([be(void 0,void 0),()=>{},()=>{}]);function X(n){var N,$;const t=n.width,c=n.height,l={processes:n.processes,messages:n.messages},h=n.processes.reduce((P,F)=>{const I=F.events.reduce((W,x)=>Math.max(W,x.time),0);return Math.max(P,I)},0),d=(N=n.ticks)==null?void 0:N.flatMap(P=>P).reduce((P,F)=>Math.max(P,F),0),m=Math.max(h,d??0),v=Mi(l.processes.length,t*.7).map(P=>P+t*.15),y=(P,F)=>{const I=v[P],W=$i(12,c-12,F/m),x=c-W;return new L(I,x)},_=n.path??ai(ji),w=_[0].start,p=_[0].end,C=ki(()=>{var W;if(!w||!p)return[];const P=[];return n.processes.forEach((x,a)=>{x.events.forEach((z,U)=>{if(U<x.events.length-1){const Q=new L(a,U),J=new L(a,U+1);P.push(be(Q,J))}})}),(W=n.messages)==null||W.forEach(x=>{const a=new L(x.from[0],x.from[1]),z=new L(x.to[0],x.to[1]);P.push(be(a,z))}),Si(P,w,p,(x,a)=>x.equals(a,.001)).reduce((x,a)=>x.length?a.length<x.length?a:x:a,[])},[w==null?void 0:w.x,w==null?void 0:w.y,p==null?void 0:p.x,p==null?void 0:p.y]),k=l.processes.map((P,F)=>{const I=P.events,W=[],x=v[F],a=Q=>y(F,Q);let z=new L(x,c-7),U=new L(x,2);if(I.length<1)W.push(e(ue,{class:"segment",start:z,end:U}));else{const Q=a(I[0].time);W.push(e(ue,{class:"segment",start:z,end:Q}));for(let G=1;G<=I.length-1;G++){const de=a(I[G-1].time),ke=a(I[G].time),xe=ie({segment:!0,highlight:(P.highlight??!1)||C.some(Ce=>Ce.equals(new L(F,G-1),.01))&&C.some(Ce=>Ce.equals(new L(F,G),.01))});W.push(e(ue,{class:xe,start:de,end:ke}))}const J=a(I[I.length-1].time);W.push(e(ue,{class:"segment",start:J,end:U}))}return e("g",{class:"process",children:[e("text",{x,y:c-2,"text-anchor":"middle",children:P.label}),W]})}),A=l.processes.flatMap((P,F)=>P.events.map((I,W)=>{var Q;const x=y(F,I.time),a=10,z=10,U=ie({highlight:(I.highlight??!1)||(P.highlight??!1)||C.some(J=>J.equals(new L(F,W),.01))||(((Q=_[0].start)==null?void 0:Q.equals(new L(F,W),.01))??!1)});return e("g",{class:"event",children:[e("circle",{cx:x.x,cy:x.y,r:2,class:U,onClick:J=>{_[1](new L(F,W))},onMouseEnter:J=>{_[2](new L(F,W))},onMouseLeave:J=>{_[2]()}}),I.label?e("foreignObject",{class:"label",x:x.x+4,y:x.y-z/2-1,width:a,height:z,children:I.label}):null]})})),B=(l.messages||[]).map((P,F)=>{const I=G=>{const de=G[0],ke=G[1],xe=l.processes[de].events[ke].time;return y(de,xe)},W=I(P.from),x=I(P.to),a=new ye().move.absolute(W).line.absolute(x).toString(),z=2e3,U=z*F/(l.messages||[]).length,Q=x.x>W.x?"auto":"auto-reverse",J=ie({link:!0,highlight:C.some(G=>G.equals(new L(P.from[0],P.from[1]),.01))&&C.some(G=>G.equals(new L(P.to[0],P.to[1]),.01))});return e(M,{children:[e("path",{d:Ii(W,x),class:J}),e("g",{class:"message",children:[e("path",{d:"M -4,-3 h 8 v 6 h -8 v -6 l 4,3 l 4,-3"}),e("animateMotion",{dur:`${z}ms`,keyPoints:"0.1; 0.9",keyTimes:"0; 1",repeatCount:"indefinite",calcMode:"linear",fill:"freeze",rotate:Q,path:a,begin:`${U}ms`}),e("animate",{attributeName:"opacity",values:"0; 1; 1; 0",keyTimes:"0; 0.3; 0.7; 1",dur:`${z}ms`,repeatCount:"indefinite",begin:`${U}ms`})]})]})}),E=($=n.ticks)==null?void 0:$.map(P=>{const F=P.map((I,W)=>y(W,I));return e(Fi,{class:"tick",points:F})}),q=P=>{_[1](),_[2]()},S=ie({"space-time":!0,selectable:!!n.path});return e("svg",{class:S,viewBox:`0 0 ${t} ${c}`,onMouseLeave:q,children:[e("defs",{children:[e("marker",{id:"arrow",viewBox:"0 0 10 10",refX:"8",refY:"5",markerWidth:"7",markerHeight:"7",orient:"auto",children:e("path",{d:"M 0 0 L 10 5 L 0 10 z"})}),e("marker",{id:"arrow-highlight",viewBox:"0 0 10 10",refX:"8",refY:"5",markerWidth:"7",markerHeight:"7",orient:"auto",children:e("path",{d:"M 0 0 L 10 5 L 0 10 z"})})]}),E,B,k,A]})}function me(n){const t=ie({link:!0});return e("span",{class:t,onMouseEnter:h=>{n.source[1]()},onMouseLeave:h=>{n.source[2]()},children:n.children})}function j(n){return{Entrance:()=>n.entrance(n.content),Exit:()=>n.exit(n.content)}}function b(n){const[t,...c]=n.children,[l,h]=V(!1),d=ie({summary:!0,open:l}),m=ie({details:!0,open:l});return e(M,{children:[e("span",{class:d,onClick:y=>{l?(h(!1),n.close&&n.close()):(h(!0),n.open&&n.open())},children:t}),l?e("div",{class:m,children:c}):null]})}function ce(n){return e("g",{class:"process",children:[e("circle",{cx:n.point.x,cy:n.point.y,r:5}),e("text",{x:n.point.x,y:n.point.y,"dominant-baseline":"middle",children:n.id})]})}function qe(n){return e("line",{class:"link",x1:n.start.x,y1:n.start.y,x2:n.end.x,y2:n.end.y})}function Ee(n){const t=new ye().move.absolute(n.start).line.absolute(n.end).toString();return e("g",{class:"message",children:[e("path",{d:"M -4,-3 h 8 v 6 h -8 v -6 l 4,3 l 4,-3"}),e("animateMotion",{dur:`${n.latency}ms`,keyTimes:"0; 0.3; 0.6; 0.9; 1",keyPoints:"0; 1; 1; 0; 0",repeatCount:"indefinite",calcMode:"linear",fill:"freeze",rotate:"auto",path:t})]})}function T(n){return e("a",{href:`#${n.id}`,children:n.children})}function K(n){return e(b,{children:[e("sup",{children:"[Note]"}),e(n.portal.Exit,{})]})}const f={clock_condition:{root:"clock-condition",list:"clock-condition-list",first:"first-clock-condition",second:"second-clock-condition"},physical_clock_condition:{first:"first-physical-clock-condition",second:"second-physical-clock-condition"},strong_clock_condition:"strong-clock-condition",implementation_rules:{first:"first-implementation-rule",second:{root:"second-implementation-rule",a:"second-implementation-rule-part-a",b:"second-implementation-rule-part-b"}},physical_implementation_rules:{first:"first-physical-implementation-rule",second:"second-physical-implementation-rule"},mutual_exclusion:{conditions:{all:"mutual-exclusion-problem-conditions",first:"first-mutual-exclusion-problem-condition",second:"second-mutual-exclusion-problem-condition",third:"third-mutual-exclusion-problem-condition"},rules:{first:"mutual-exclusion-problem_first-rule",second:"mutual-exclusion-problem-second-rule",third:"mutual-exclusion-problem-third-rule",fourth:"mutual-exclusion-problem-fourth-rule",fifth:{root:"mutual-exclusion-problem-fifth-rule",first:"mutual-exclusion-problem-fifth-rule-first",second:"mutual-exclusion-problem-fifth-rule-second"}}},notes:{event:"event-note",message:"message-note",ordering:"ordering-note",eventually:"eventually-note",acknowledgement:"acknowledgement-note",receive_message:"receive-message-note",release:"release-note",time:"time-note",limit:"limit-note"},references:{relativity:"reference_relativity",space_time:"reference_space-time",lamport_implementation:"reference_lamport-implementation",system_time:"reference_system-time"},sections:{abstract:"abstract",introduction:"introduction",partial_ordering:"partial-ordering",logical_clocks:"logical-clocks",total_ordering:"total-ordering",anomalous_behavior:"anomalous-behavior",physical_clocks:"physical-clocks",conclusion:"conclusion",appendix:"appendix",notes:"notes",references:"references"},figures:{first:"figure-1",second:"figure-2",third:"figure-3"}},D={happened_before:o.operators.arrows.right.single,not_happend_before:o.operators.arrows.right.not_single},Te={first:[e(X,{width:50,height:50,processes:[{events:[{time:0,label:e(i,{children:"a"})},{time:10,label:e(i,{children:"b"})}],label:"a process"}]}),e(X,{width:50,height:50,processes:[{events:[{time:0,label:e(i,{children:"a"})},{time:10},{time:20},{time:30,label:e(i,{children:"b"})}],label:"a process"}]})],second:[e(X,{width:70,height:50,processes:[{events:[{time:0,label:e(i,{children:"a"})}],label:"sender"},{events:[{time:10,label:e(i,{children:"b"})}],label:"receiver"}],messages:[{from:[0,0],to:[1,0]}]})],third:[e(X,{width:80,height:80,processes:[{events:[{time:0,label:e(i,{children:"a"})},{time:10,label:e(i,{children:"b"})}]},{events:[{time:20,label:e(i,{children:"c"})}]}],messages:[{from:[0,1],to:[1,0]}]}),e(X,{width:80,height:80,processes:[{events:[{time:0,label:e(i,{children:"a"})}]},{events:[{time:10,label:e(i,{children:"b"})},{time:20,label:e(i,{children:"c"})}]}],messages:[{from:[0,0],to:[1,0]}]}),e(X,{width:50,height:50,processes:[{events:[{time:0,label:e(i,{children:"a"})},{time:10,label:e(i,{children:"b"})},{time:20,label:e(i,{children:"c"})}]}]})]};function Ai(){const n=Y(),t=Y(),c=Y(),l=Y(),h=Y(),d=Y(),m=Y(),v=Y(),y=Wi(),_=Y({on:()=>{y[1](new L(0,0)),y[2](new L(2,3))},off:()=>{y[1](),y[2]()}}),w={event:j({entrance:a=>a,exit:a=>a,content:e("p",{children:"The choice of what constitutes an event affects the ordering of events in a process. For example, the receipt of a message might denote the setting of an interrupt bit in a computer, or the execution of a subprogram to handle that interrupt. Since interrupts need not be handled in the order that they occur, this choice will affect the ordering of a process' message-receiving events."})}),message:j({entrance:a=>a,exit:a=>a,content:e("p",{children:"Observe that messages may be received out of order. We allow the sending of several messages to be a single event, but for convenience we will assume that the receipt of a single message does not coincide with the sending or receipt of any other message."})}),ordering:j({entrance:a=>a,exit:a=>a,content:e("p",{children:["The ordering ",e(r,{children:o.operators.precedes}),' establishes a priority among the processes. If a "fairer" method is desired, then ',e(r,{children:o.operators.precedes})," can be made a function of the clock value. For example, if ",e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"a"}),e(r,{children:o.operators.angle.right}),e(r,{children:o.operators.equals}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"b"}),e(r,{children:o.operators.angle.right})]})," and ",e(u,{children:[e(i,{children:"j"}),e(r,{children:o.operators.less_than}),e(i,{children:"i"})]}),", then we can let ",e(u,{children:[e(i,{children:"a"}),e(r,{children:o.operators.arrows.right.double}),e(i,{children:"b"})]})," if ",e(u,{children:[e(i,{children:"j"}),e(r,{children:o.operators.less_than}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"a"}),e(r,{children:o.operators.angle.right}),e(i,{children:"mod"}),e(i,{children:"N"}),e(r,{children:"less-than-equal"}),e(i,{children:"i"})]}),", and ",e(u,{children:[e(i,{children:"b"}),e(r,{children:o.operators.arrows.right.double}),e(i,{children:"a"})]})," otherwise; where ",e(i,{children:"N"})," is the total number of processes."]})}),eventually:j({entrance:a=>a,exit:a=>a,content:e("p",{children:'The term "eventually" should be made precise, but that would require too long a diversion from our main topic.'})}),acknowledgement:j({entrance:a=>a,exit:a=>a,content:e("p",{children:["This acknowledgement message need not be sent if ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"j"})]})," has already sent a message to ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," timestamped later than ",e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),"."]})}),receive_message:j({entrance:a=>a,exit:a=>a,content:e("p",{children:["If ",e(u,{children:[e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e(r,{children:o.operators.precedes}),e(s,{children:[e(i,{children:"P"}),e(i,{children:"j"})]})]}),", then ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," need only have received a message timestamped ",e(u,{children:[e(r,{children:"greater-than-equal"}),e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]})]})," from ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"j"})]}),"."]})}),release:j({entrance:a=>a,exit:a=>a,content:e("p",{children:["If each process does not stricly alternate ",e("em",{children:"request"})," and ",e("em",{children:"release"})," commands, then executing a ",e("em",{children:"release"})," command could delete zero, one, or more than one request from the queue."]})}),time:j({entrance:a=>a,exit:a=>a,content:e("p",{children:["We will assume a Newtonian space-time. If the relative motion of the clocks or gravitational effects are not negligible, then ",e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]})," must be deduced from the actual clock reading by transforming from proper time to the arbitrarily chosen time coordinate."]})}),limit:j({entrance:a=>a,exit:a=>a,content:e("p",{children:e(u,{display:"block",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:o.operators.prime}),e(r,{children:"-"}),e(g,{value:0}),e(r,{children:")"}),e(r,{children:"="}),e(Ti,{children:[e(i,{children:"lim"}),e(u,{children:[e(i,{children:o.greek.delta}),e(r,{children:o.operators.arrows.right.single}),e(g,{value:0})]})]}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:o.operators.prime}),e(r,{children:"-"}),e(r,{children:"|"}),e(i,{children:o.greek.delta}),e(r,{children:"|"}),e(r,{children:")"})]})})})},p=j({entrance:a=>e("p",{id:f.clock_condition.root,children:a}),exit:a=>e(M,{children:[e(T,{id:f.clock_condition.root,children:"Go to definition."}),e("p",{children:a})]}),content:e(M,{children:[e("em",{children:"Clock Condition."})," For any events ",e(i,{description:"first event",children:"a"}),", ",e(i,{description:"second event",children:"b"}),": if ",e(u,{description:"the first event happened before the second event",children:[e(i,{description:"first event",children:"a"}),e(r,{description:"happened before",children:o.operators.arrows.right.single}),e(i,{description:"second event",children:"b"})]})," then ",e(u,{description:"the logical time of the first event is less than the logical time of the second event",children:[e(u,{description:"the logical time of the first event",children:[e(i,{children:"C"}),e(r,{children:o.operators.angle.left}),e(i,{description:"first event",children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.less_than}),e(u,{description:"the logical time of the second event",children:[e(i,{children:"C"}),e(r,{children:o.operators.angle.left}),e(i,{description:"second event",children:"b"}),e(r,{children:o.operators.angle.right})]})]}),"."]})}),C=j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.clock_condition.first,children:"Go to definition."}),a]}),content:e("p",{children:["If ",e(i,{children:"a"})," and ",e(i,{children:"b"})," are events in process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," and ",e(i,{children:"a"})," comes before ",e(i,{children:"b"}),", then ",e(u,{children:[e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the first event",children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.less_than}),e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the second event",children:"b"}),e(r,{children:o.operators.angle.right})]})]})]})}),k=j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.clock_condition.second,children:"Go to definition."}),a]}),content:e("p",{children:["If ",e(i,{children:"a"})," is the sending of a message by process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," and ",e(i,{children:"b"})," is the receipt of that message by process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"j"})]}),", then ",e(u,{description:"the logical time of sending a message is less than the logical time of receiving the message",children:[e(u,{description:"the logical time of sending a message",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the event of sending a message",children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.less_than}),e(u,{description:"the logical time of receiving the message",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the event of receiving the message",children:"b"}),e(r,{children:o.operators.angle.right})]})]})]})}),A=j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.implementation_rules.second.a,children:"Go to definition."}),a]}),content:e("p",{children:["If event ",e(i,{description:"an event",children:"a"})," is the sending of a message ",e(i,{description:"a message",children:"m"})," by process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]}),", then the message ",e(i,{description:"the message",children:"m"})," contains a timestamp ",e(u,{description:"the timestamp of the message equal to the logical timestamp of the process's clock register",children:[e(s,{description:"the timestamp of the message",children:[e(i,{children:"T"}),e(i,{description:"the message",children:"m"})]}),e(r,{children:o.operators.equals}),e(u,{description:"the logical timestamp of the event in the process",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"a"}),e(r,{children:o.operators.angle.right})]})]}),"."]})}),B=j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.implementation_rules.second.b,children:"Go to definition."}),a]}),content:e("p",{children:["Upon receiving a message ",e(i,{description:"a message",children:"m"}),", process ",e(s,{description:"the receiving process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})," sets ",e(s,{description:"the clock register for the receiving process",children:[e(i,{children:"C"}),e(i,{children:"j"})]})," greater than or equal to its present value and greater than ",e(s,{description:"the timestamp of the received message",children:[e(i,{children:"T"}),e(i,{description:"the received message",children:"m"})]}),"."]})}),E={First:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.implementation_rules.first,children:"Go to definition."}),a]}),content:e("p",{children:["Each process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," increments ",e(s,{description:"the clock register of the process",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," between any two successive events."]})}),Second:{Root:j({entrance:a=>e("ol",{type:"a",children:[e("li",{id:f.implementation_rules.second.a,children:e(A.Entrance,{})}),e("li",{id:f.implementation_rules.second.b,children:e(B.Entrance,{})})]}),exit:a=>e(M,{children:[e(T,{id:f.implementation_rules.second.root,children:"Go to definition."}),a]}),content:e("ol",{type:"a",children:[e("li",{children:e(A.Entrance,{})}),e("li",{children:e(B.Entrance,{})})]})}),A,B}},q={First:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.conditions.first,children:"Go to definition."}),a]}),content:e("p",{children:"A process which has been granted the resource must release it before it can be granted to another process."})}),Second:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.conditions.second,children:"Go to definition."}),a]}),content:e("p",{children:"Different requests for the resource must be granted in the order in which they are made."})}),Third:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.conditions.third,children:"Go to definition."}),a]}),content:e("p",{children:"If every process which is granted the resource eventually releases it, then every request is eventually granted."})})},S=j({entrance:a=>e("ol",{type:"I",id:f.mutual_exclusion.conditions.all,children:[e("li",{id:f.mutual_exclusion.conditions.first,children:e(q.First.Entrance,{})}),e("li",{id:f.mutual_exclusion.conditions.second,children:e(q.Second.Entrance,{})}),e("li",{id:f.mutual_exclusion.conditions.third,children:e(q.Third.Entrance,{})})]}),exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.conditions.all,children:"Go to definition."}),a]}),content:e("ol",{children:[e("li",{children:e(q.First.Exit,{})}),e("li",{children:e(q.Second.Exit,{})}),e("li",{children:e(q.Third.Exit,{})})]})}),N={First:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.rules.fifth.first,children:"Go to definition."}),a]}),content:e("p",{children:["There is a ",e(u,{children:[e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:":"}),e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"requests resource"})]})," message in its request queue which is ordered before any other request in its queue by the relation ",e(r,{children:o.operators.arrows.right.double}),'. (To define the relation "',e(r,{children:o.operators.arrows.right.double}),'" for messages, we identify a message with the event of sending it.)']})}),Second:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.rules.fifth.second,children:"Go to definition."}),a]}),content:e("p",{children:[e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," has received a message from every other process timestamped later than ",e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),". ",e(K,{portal:w.receive_message})]})})},$={Second:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.rules.second,children:"Go to definition."}),a]}),content:e("p",{children:["When process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"j"})]})," receives the message ",e(u,{children:[e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:":"}),e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"requests resource"})]}),", it places it on its request queue and sends a (timestamped) acknowledgement message to ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),". ",e(K,{portal:w.acknowledgement})]})}),Third:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.rules.third,children:"Go to definition."}),a]}),content:e("p",{children:["To release the resource, process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," removes any ",e(u,{children:[e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:":"}),e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"requests resource"})]})," message from its request queue and sends a (timestamped) ",e(u,{children:[e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"releases resource"})]})," message to every other process."]})}),Fourth:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.rules.fourth,children:"Go to definition."}),a]}),content:e("p",{children:["When process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"j"})]})," receives a ",e(u,{children:[e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"releases resource"})]})," message, it removes any ",e(u,{children:[e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:":"}),e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"requests resource"})]})," message from its queue."]})}),Fifth:{Root:j({entrance:a=>e(M,{children:[a,e("ol",{type:"i",children:[e("li",{id:f.mutual_exclusion.rules.fifth.first,children:e(N.First.Entrance,{})}),e("li",{id:f.mutual_exclusion.rules.fifth.second,children:e(N.Second.Entrance,{})})]})]}),exit:a=>e(M,{children:[e(T,{id:f.mutual_exclusion.rules.fifth.root,children:"Go to definition."}),a,e("ol",{type:"i",children:[e("li",{children:e(N.First.Exit,{})}),e("li",{children:e(N.Second.Exit,{})})]})]}),content:e("p",{children:["Process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," is granted the resource when the following two conditions are satisfied:"]})}),First:N.First,Second:N.Second}},P=j({entrance:a=>e("p",{id:f.strong_clock_condition,children:a}),exit:a=>e(M,{children:[e(T,{id:f.strong_clock_condition,children:"Go to definition."}),e("p",{children:a})]}),content:e(M,{children:[e("em",{children:"Strong Clock Condition."})," For any events ",e(i,{description:"an event",children:"a"}),", ",e(i,{description:"another event",children:"b"})," in ",e(i,{description:"the set of all system events",children:o.greek.zeta}),": if ",e(u,{children:[e(i,{description:"the first event",children:"a"}),e(r,{children:o.operators.arrows.right.thick}),e(i,{description:"the second event",children:"b"})]})," then ",e(u,{description:"the logical timestamp of the first event is less than the logical timestamp of the second event",children:[e(u,{description:"the logical timestamp of the first event",children:[e(i,{children:"C"}),e(r,{children:o.operators.angle.left}),e(i,{children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.less_than}),e(u,{description:"the logical timestamp of the second event",children:[e(i,{children:"C"}),e(r,{children:o.operators.angle.left}),e(i,{children:"b"}),e(r,{children:o.operators.angle.right})]})]}),"."]})}),F=j({entrance:a=>e("p",{id:f.physical_clock_condition.first,children:a}),exit:a=>e(M,{children:[e(T,{id:f.physical_clock_condition.first,children:"Go to definition."}),e("p",{children:a})]}),content:e(M,{children:["There exists a constant ",e(u,{children:[e(i,{description:"maximum clock rate error",children:o.greek.kappa}),e(r,{children:o.operators.much_less_than}),e(g,{value:1})]})," such that for all ",e(i,{children:"i"}),": ",e(u,{description:"the clock rate error is less than the maximum clock rate error",children:[e(u,{children:[e(r,{children:"|"}),e(u,{children:[e(ne,{description:"the clock rate",children:[e(u,{children:[e(r,{children:"d"}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:"dt"})]}),e(r,{children:"-"}),e(g,{value:1})]}),e(r,{children:"|"})]}),e(r,{children:o.operators.less_than}),e(i,{children:o.greek.kappa})]}),"."]})}),I=j({entrance:a=>e("p",{id:f.physical_clock_condition.second,children:a}),exit:a=>e(M,{children:[e(T,{id:f.physical_clock_condition.second,children:"Go to definition."}),e("p",{children:a})]}),content:e(M,{children:["For all ",e(i,{children:"i"}),", ",e(i,{children:"j"}),": ",e(u,{children:[e(u,{description:"the difference between two clocks' time",children:[e(r,{children:"|"}),e(u,{description:"one clock's time",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:"-"}),e(u,{description:"another clock's time",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:"|"})]}),e(r,{children:o.operators.less_than}),e(i,{description:"maximum clock drift",children:o.greek.epsilon})]}),"."]})}),W={First:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.physical_implementation_rules.first,children:"Go to definition."}),a]}),content:e("p",{children:["For each ",e(i,{children:"i"}),", if ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," does not receive a message at physical time ",e(i,{description:"physical time",children:"t"}),", then ",e(s,{description:"the process's clock",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," is differentiable at ",e(i,{description:"physical time",children:"t"})," and ",e(u,{description:"the clock speed is positive",children:[e(ne,{description:"the clock speed",children:[e(u,{children:[e(r,{children:"d"}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:"dt"})]}),e(r,{children:o.operators.greater_than}),e(g,{value:0})]}),"."]})}),Second:j({entrance:a=>a,exit:a=>e(M,{children:[e(T,{id:f.physical_implementation_rules.second,children:"Go to definition."}),a]}),content:e("ol",{type:"a",children:[e("li",{children:e("p",{children:["If ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," sends a message ",e(i,{description:"a message",children:"m"})," at physical time ",e(i,{description:"physical sent time",children:"t"}),", then ",e(i,{description:"the message",children:"m"})," contains a timestamp ",e(u,{children:[e(s,{description:"the message's timestamp",children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:"="}),e(u,{description:"the clock's value at sent time",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]})]}),"."]})}),e("li",{children:e("p",{children:["Upon receiving a message ",e(i,{description:"a message",children:"m"})," at time ",e(u,{description:"physical received time",children:[e(i,{children:"t"}),e(r,{children:o.operators.prime})]}),", process ",e(s,{description:"the receiving process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})," sets ",e(u,{description:"the receiving process's clock at the received time",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(u,{description:"physical received time",children:[e(i,{children:"t"}),e(r,{children:o.operators.prime})]}),e(r,{children:")"})]})," equal to maximum ",e(u,{children:[e(r,{children:"("}),e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:o.operators.prime}),e(r,{children:"-"}),e(g,{value:0}),e(r,{children:")"})]}),e(r,{children:","}),e(u,{children:[e(s,{description:"the message's timestamp",children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:"+"}),e(s,{description:"the message's minimum delay",children:[e(i,{children:o.greek.mu}),e(i,{children:"m"})]})]}),e(r,{children:")"})]}),". ",e(K,{portal:w.limit})]})})]})})},x={1:new L(10,10),2:new L(40,10),3:new L(25,40)};return e("article",{children:[e("header",{children:"Time, Clocks, and the Ordering of Events in a Distributed System"}),e("address",{children:[e("span",{class:"name",children:"Leslie Lamport"}),e("span",{class:"institution",children:"Massachusetts Computer Associates, Inc."})]}),e("section",{id:f.sections.abstract,children:[e("header",{children:"Abstract"}),e("p",{children:"The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become."})]}),e("section",{children:[e("header",{children:"Table of Contents"}),e("ol",{children:[e("li",{children:e(T,{id:f.sections.introduction,children:"Introduction"})}),e("li",{children:e(T,{id:f.sections.partial_ordering,children:"The Partial Ordering"})}),e("li",{children:e(T,{id:f.sections.logical_clocks,children:"Logical Clocks"})}),e("li",{children:e(T,{id:f.sections.total_ordering,children:"Ordering the Events Totally"})}),e("li",{children:e(T,{id:f.sections.anomalous_behavior,children:"Anomalous Behavior"})}),e("li",{children:e(T,{id:f.sections.physical_clocks,children:"Physical Clocks"})}),e("li",{children:e(T,{id:f.sections.conclusion,children:"Conclusion"})}),e("li",{children:e(T,{id:f.sections.appendix,children:"Appendix"})}),e("li",{children:e(T,{id:f.sections.notes,children:"Notes"})}),e("li",{children:e(T,{id:f.sections.references,children:"References"})})]})]}),e("section",{id:f.sections.introduction,children:[e("header",{children:"Introduction"}),e("p",{children:"The concept of time is fundamental to our way of thinking. It is derived from the more basic concept of the order in which events occur. We say that something happened at 3:15 if it occurred after our clock read 3:15 and before it read 3:16. The concept of the temporal ordering of events pervades our thinking about systems. For example, in an airline reservation system we specify that a request for a reservation should be granted if it is made before the flight is filled. However, we will see that this concept must be carefully reexamined when considering events in a distributed system."}),e("ol",{class:"visual",children:[e("li",{children:[e("p",{children:"A distributed system consists of a collection of distinct processes which are spatially separated,"}),e("figure",{children:e("svg",{class:"distributed-system",viewBox:"0 0 50 50",children:[e(ce,{id:1,point:x[1]}),e(ce,{id:2,point:x[2]}),e(ce,{id:3,point:x[3]})]})})]}),e("li",{children:[e("p",{children:"and which communicate with one another by exchanging messages."}),e("figure",{children:e("svg",{class:"distributed-system",viewBox:"0 0 50 50",children:[e(qe,{start:x[1],end:x[2]}),e(qe,{start:x[1],end:x[3]}),e(qe,{start:x[2],end:x[3]}),e(Ee,{start:x[1],end:x[2],latency:2500}),e(Ee,{start:x[1],end:x[3],latency:3500}),e(Ee,{start:x[2],end:x[3],latency:4500}),e(ce,{id:1,point:x[1]}),e(ce,{id:2,point:x[2]}),e(ce,{id:3,point:x[3]})]})})]})]}),e("p",{children:"A network of interconnected computers, such as the ARPA net, is a distributed system. A single computer can also be viewed as a distributed system in which the central control unit, the memory units, and the input-output channels are separate processes. A system is distributed if the message transmission delay is not negligible compared to the time between events in a single process."}),e("p",{children:"We will concern ourselves primarily with systems of spatially separated computers. However, many of our remarks will apply more generally. In particular, a multiprocessing system on a single computer involves problems similar to those of a distributed system because of the unpredictable order in which certain events can occur."}),e("p",{children:'In a distributed system, it is sometimes impossible to say that one of two events occurred first. The relation "happened before" is therefore only a partial ordering of the events in the system. We have found that problems often arise because people are not fully aware of this fact and its implications.'}),e("p",{children:'In this paper, we discuss the partial ordering defined by the "happened before" relation, and give a distributed algorithm for extending it to a consistent total ordering of all the events. This algorithm can provide a useful mechanism for implementing a distributed system. We illustrate its use with a simple method for solving synchronization problems. Unexpected, anomalous behavior can occur if the ordering obtained by this algorithm differs from that perceived by the user. This can be avoided by introducing real, physical clocks. We describe a simple method for synchronizing these clocks, and derive an upper bound on how far out of synchrony they can drift.'})]}),e("section",{id:f.sections.partial_ordering,children:[e("header",{children:"The Partial Ordering"}),e("p",{children:["Most people would probably say that an event ",e(i,{description:"an event",children:"a"})," happened before an event ",e(i,{description:"another event",children:"b"})," if ",e(i,{description:"the first event)",children:"a"})," happened at an earlier time than ",e(i,{description:"the second event",children:"b"}),'. They might justify this definition in terms of physical theories of time. However, if a system is to meet a specification correctly, then that specification must be given in terms of events observable within the system. If the specification is in terms of physical time, then the system must contain real clocks. Even if it does contain real clocks, there is still the problem that such clocks are not perfectly accurate and do not keep precise physical time. We will therefore define the "happened before" relation without using physical clocks.']}),e("p",{children:["We begin by defining our system more precisely. We assume that the system is composed of a collection of processes. Each process consists of a sequence of events. Depending upon the application, the execution of a subprogram on a computer could be one event, or the execution of a single machine instruction could be one event. We are assuming that the events of a process form a sequence, where ",e(i,{description:"the first event",children:"a"})," occurs before ",e(i,{description:"the second event",children:"b"})," in this sequence if ",e(i,{description:"the first event",children:"a"})," happens before ",e(i,{description:"the second event",children:"b"}),". In other words, a single process is defined to be a set of events with an a priori total ordering. This seems to be what is generally meant by a process. ",e(K,{portal:w.event})," It would be trivial to extend our definition to allow a process to split into distinct subprocesses, but we will not bother to do so."]}),e("p",{children:['We assume that sending or receiving a message is an event in a process. We can then define the "happened before" relation, denoted by "',e(r,{description:"happened before",children:D.happened_before}),'", as follows.']}),e("p",{children:[e("em",{children:"Definition"}),'. The relation "',e(r,{description:"happened before",children:D.happened_before}),'" on the set of events of a system is the smallest relation satisfying the following three conditions:']}),e("ol",{children:[e("li",{children:[e("p",{children:["If ",e(i,{description:"an event",children:"a"})," and ",e(i,{description:"another event",children:"b"})," are events in the same process, and ",e(i,{description:"the first event",children:"a"})," comes before ",e(i,{description:"the second event",children:"b"}),", then ",e(u,{description:"the first event happened before the second event",children:[e(i,{description:"the first event",children:"a"}),e(r,{description:"happened before",children:D.happened_before}),e(i,{description:"the second event",children:"b"})]}),"."]}),e("ul",{class:"example visual",children:Te.first.map(a=>e("li",{children:a}))})]}),e("li",{children:[e("p",{children:["If ",e(i,{description:"an event",children:"a"})," is the sending of a message by one process and ",e(i,{description:"another event",children:"b"})," is the receipt of the same message by another process, then ",e(u,{description:"the event of sending a message happened before the event of receiving the message",children:[e(i,{description:"the event of sending a message",children:"a"}),e(r,{description:"happened before",children:D.happened_before}),e(i,{description:"the event of receiving the message",children:"b"})]}),"."]}),e("ul",{class:"visual example",children:Te.second.map(a=>e("li",{children:a}))})]}),e("li",{children:[e("p",{children:["If ",e(u,{description:"a first event happened before a second event",children:[e(i,{description:"the first event",children:"a"}),e(r,{description:"happened before",children:D.happened_before}),e(i,{description:"the second event",children:"b"})]})," and ",e(u,{description:"a second event happened before a third event",children:[e(i,{description:"the second event",children:"b"}),e(r,{description:"happened before",children:D.happened_before}),e(i,{description:"the third event",children:"c"})]})," then ",e(u,{description:"a first event happened before a third event",children:[e(i,{description:"the first event",children:"a"}),e(r,{description:"happened before",children:D.happened_before}),e(i,{description:"the third event",children:"c"})]}),"."]}),e("ul",{class:"visual example",children:Te.third.map(a=>e("li",{children:a}))})]})]}),e("p",{children:["Two distinct events ",e(i,{description:"an event",children:"a"})," and ",e(i,{description:"another event",children:"b"})," are said to be concurrent if ",e(u,{description:"the first event did not happen before the second event",children:[e(i,{description:"the first event",children:"a"}),e(r,{description:"did not happen before",children:D.not_happend_before}),e(i,{description:"the second event",children:"b"})]})," and ",e(u,{description:"the second event did not happen before the first event",children:[e(i,{description:"the second event",children:"b"}),e(r,{description:"did not happen before",children:D.not_happend_before}),e(i,{description:"the first event event",children:"a"})]}),"."]}),e("p",{children:["We assume that ",e(u,{description:"an event did not happen before itself",children:[e(i,{description:"an event",children:"a"}),e(r,{description:"did not happen before",children:D.not_happend_before}),e(i,{description:"the same event",children:"a"})]})," for any event ",e(i,{description:"an event",children:"a"}),". (Systems in which an event can happen before itself do not seem to be physically meaningful.) This implies that ",e(r,{description:"happened before",children:D.happened_before})," is an irreflexive partial ordering on the set of all events in the system."]}),e("p",{children:['It is helpful to view this definition in terms of a "space-time diagram" such as ',e(T,{id:f.figures.first,children:"Figure 1"}),". The horizontal direction represents space, and the vertical direction represents time – later times being higher than earlier ones. The dots denote events, the vertical lines denote processes, and the wavy lines denote messages. ",e(K,{portal:w.message})," It is easy to see that ",e(u,{description:"the first event happened before the second event",children:[e(i,{description:"the first event",children:"a"}),e(r,{description:"happened before",children:D.happened_before}),e(i,{description:"the second event",children:"b"})]})," means that one can go from ",e(i,{description:"the first event",children:"a"})," to ",e(i,{description:"the second event",children:"b"})," in the diagram by moving forward in time along process and message lines. For example, we have ",e(u,{description:"the first event in process P happened before the fourth event in process R",source:_,children:[e(s,{description:"the first event in process P",source:n,children:[e(i,{children:"p"}),e(g,{value:1})]}),e(r,{description:"happened before",children:D.happened_before}),e(s,{description:"the fourth event in process R",source:d,children:[e(i,{children:"r"}),e(g,{value:4})]})]})," in ",e(T,{id:f.figures.first,children:"Figure 1"}),"."]}),e("figure",{id:f.figures.first,class:"space-time",children:[e(X,{width:150,height:150,path:y,processes:[{label:"process P",highlight:m[0],events:[{time:0,highlight:n[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:1})]})},{time:20,label:e(s,{children:[e(i,{children:"p"}),e(g,{value:2})]})},{time:40,highlight:c[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:3})]})},{time:60,highlight:l[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:4})]})}]},{label:"process Q",highlight:v[0],events:[{time:0,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:1})]})},{time:10,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:2})]})},{time:20,highlight:h[0],label:e(s,{children:[e(i,{children:"q"}),e(g,{value:3})]})},{time:30,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:4})]})},{time:40,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:5})]})},{time:50,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:6})]})},{time:60,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:7})]})}]},{label:"process R",events:[{time:0,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:1})]})},{time:20,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:2})]})},{time:40,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:3})]})},{time:60,highlight:d[0],label:e(s,{children:[e(i,{children:"r"}),e(g,{value:4})]})}]}],messages:[{from:[0,0],to:[1,1]},{from:[1,0],to:[0,1]},{from:[1,4],to:[0,3]},{from:[1,0],to:[2,3]},{from:[1,3],to:[2,2]},{from:[2,1],to:[1,6]}]}),e("figcaption",{children:"Figure 1"})]}),e("p",{children:["Another way of viewing the definition is to say that ",e(u,{description:"an event happened before another event",children:[e(i,{description:"an event",children:"a"}),e(r,{description:"happened before",children:o.operators.arrows.right.single}),e(i,{description:"another event",children:"b"})]})," means that it is possible for event ",e(i,{description:"an event",children:"a"})," to causally affect event ",e(i,{description:"another event",children:"b"}),". Two events are concurrent if neither can causally affect the other. For example, events ",e(s,{description:"the third event in process P",source:c,children:[e(i,{children:"p"}),e(g,{value:3})]})," and ",e(s,{description:"the third event in process Q",source:h,children:[e(i,{children:"q"}),e(g,{value:3})]})," of ",e(T,{id:f.figures.first,children:"Figure 1"})," are concurrent. Even though we have drawn the diagram to imply that ",e(s,{description:"the third event in process Q",source:h,children:[e(i,{children:"q"}),e(g,{value:3})]})," occurs at an earlier physical time than ",e(s,{description:"the third event in process P",source:c,children:[e(i,{children:"p"}),e(g,{value:3})]}),", ",e(me,{source:m,children:"process P"})," cannot know what ",e(me,{source:v,children:"process Q"})," did at ",e(s,{description:"the third event in process Q",source:h,children:[e(i,{children:"q"}),e(g,{value:3})]})," until it receives the message at ",e(s,{description:"the fourth event in process P",source:l,children:[e(i,{children:"p"}),e(g,{value:4})]}),". (Before event ",e(s,{description:"the fourth event in process P",source:l,children:[e(i,{children:"p"}),e(g,{value:4})]}),", ",e(me,{source:m,children:"P"})," could at most know what ",e(me,{source:v,children:"Q"})," was ",e("em",{children:"planning"})," to do at ",e(s,{description:"the third event in process Q",source:h,children:[e(i,{children:"q"}),e(g,{value:3})]}),")."]}),e("p",{children:["This definition will appear quite natural to the reader familiar with the invariant space-time formulation of special relativity, as described for example in ",e(pe,{href:f.references.relativity,children:"[1]"})," or the first chapter of ",e(pe,{href:f.references.space_time,children:"[2]"}),". In relativity, the ordering of events is defined in terms of messages that could be sent. However, we have taken the more pragmatic approach of only considering messages that actually are sent. We should be able to determine if a system performed correctly by knowing only those events which did occur, without knowing which events could have occurred."]})]}),e("section",{id:f.sections.logical_clocks,children:[e("header",{children:"Logical Clocks"}),e("p",{children:["We now introduce clocks into the system. We begin with an abstract point of view in which a clock is just a way of assigning a number to an event, where the number is thought of as the time at which the event occurred. More precisely, we define a clock ",e(s,{description:"a process's clock",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," for each process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," to be a function which assigns a number ",e(u,{description:"the process's timestamp of the event",children:[e(s,{description:"a process's clock",children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"an event",children:"a"}),e(r,{children:o.operators.angle.right})]})," to any event ",e(i,{description:"an event",children:"a"})," in that process. The entire system of clocks is represented by the function ",e(i,{children:"C"})," which assigns to any event ",e(i,{description:"an event",children:"b"})," the number ",e(u,{description:"the system's timestamp of an event",children:[e(i,{description:"the system's clock",children:"C"}),e(r,{children:o.operators.angle.left}),e(i,{description:"event in process j",children:"b"}),e(r,{children:o.operators.angle.right})]}),", where ",e(u,{children:[e(u,{description:"the system's timestamp of the event",children:[e(i,{description:"system of clocks for all processes",children:"C"}),e(r,{children:o.operators.angle.left}),e(i,{description:"event in process j",children:"b"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.equals}),e(u,{description:"the process's timestamp of the event",children:[e(s,{description:"the event's process's clock",children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"event in process j",children:"b"}),e(r,{children:o.operators.angle.right})]})]})," if ",e(i,{description:"an event",children:"b"})," is an event in process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"j"})]}),". For now, we make no assumption about the relation of the numbers ",e(u,{description:"the process's timestamp of an event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"a"}),e(r,{children:o.operators.angle.right})]})," to physical time, so we can think of the clocks ",e(s,{description:"a process's clock",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," as logical rather than physical clocks. They may be implemented by counters with no actual timing mechanism."]}),e("p",{children:["We now consider what it means for such a system of clocks to be correct. We cannot base our definition of correctness on physical time, since that would require introducing clocks which keep physical time. Our definition must be based on the order in which events occur. The strongest reasonable condition is that if an event ",e(i,{children:"a"})," occurs before another event ",e(i,{children:"b"}),", then ",e(i,{children:"a"})," should happen at an earlier time than ",e(i,{children:"b"}),". We state this condition more formally as follows."]}),e(p.Entrance,{}),e("p",{children:["Note that we cannot expect the converse condition to hold as well, since that would imply that any two concurrent events must occur at the same time. In ",e(T,{id:f.figures.first,children:"Figure 1"}),", ",e(s,{description:"the second event in process P",source:t,children:[e(i,{children:"p"}),e(g,{value:2})]})," and ",e(s,{description:"the third event in process P",source:c,children:[e(i,{children:"p"}),e(g,{value:3})]})," are both concurrent with ",e(s,{description:"the third event in process Q",source:h,children:[e(i,{children:"q"}),e(g,{value:3})]}),", so this would mean that they both must occur at the same time as ",e(s,{description:"the third event in process Q",source:h,children:[e(i,{children:"q"}),e(g,{value:3})]}),", which would contradict the ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," because ",e(u,{description:"the second event in process P happened before the third event in process P",children:[e(s,{description:"the second event in process P",children:[e(i,{children:"p"}),e(g,{value:2})]}),e(r,{description:"happend before",children:o.operators.arrows.right.single}),e(s,{description:"the third event in process P",children:[e(i,{children:"p"}),e(g,{value:3})]})]}),"."]}),e("p",{children:['It is easy to see from our definition of the relation "',e(r,{description:"happend before relation",children:o.operators.arrows.right.single}),'" that the ',e(b,{children:["Clock Condition",e(p.Exit,{})]})," is satisfied if the following two conditions hold."]}),e("ol",{id:f.clock_condition.list,children:[e("li",{id:f.clock_condition.first,children:e(C.Entrance,{})}),e("li",{id:f.clock_condition.second,children:e(k.Entrance,{})})]}),e("p",{children:[`Let us consider the clocks in terms of a space-time diagram. We imagine that a process' clock "ticks" through every number, with the ticks occurring between the process' events. For example, if `,e(i,{children:"a"})," and ",e(i,{children:"b"})," are consecutive events in process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," with ",e(u,{children:[e(u,{description:"the logical time of the first event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the first event",children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.equals}),e(g,{value:4})]})," and ",e(u,{children:[e(u,{description:"the logical time of the second event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the second event",children:"b"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.equals}),e(g,{value:7})]}),', then clock ticks 5, 6, and 7 occur between the two events. We draw a dashed "tick line" through all the like-numbered ticks of the different processes. The space-time diagram of ',e(T,{id:f.figures.first,children:"Figure 1"})," might then yield the picture in ",e(T,{id:f.figures.second,children:"Figure 2"}),". ",e(b,{children:["Condition C1",e(C.Exit,{})]})," means that there must be a tick line between any two events on a process line, and ",e(b,{children:["condition C2",e(k.Exit,{})]})," means that every message line must cross a tick line. From the pictorial meaning of ",e(r,{description:"the happened-before relation",children:o.operators.arrows.right.single}),", it is easy to see why these two conditions imply the ",e(b,{children:["Clock Condition",e(p.Exit,{})]}),"."]}),e("figure",{id:f.figures.second,class:"space-time",children:[e(X,{width:150,height:150,path:y,processes:[{label:"process P",highlight:m[0],events:[{time:0,highlight:n[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:1})]})},{time:20,label:e(s,{children:[e(i,{children:"p"}),e(g,{value:2})]})},{time:40,highlight:c[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:3})]})},{time:60,highlight:l[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:4})]})}]},{label:"process Q",highlight:v[0],events:[{time:0,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:1})]})},{time:10,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:2})]})},{time:20,highlight:h[0],label:e(s,{children:[e(i,{children:"q"}),e(g,{value:3})]})},{time:30,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:4})]})},{time:40,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:5})]})},{time:50,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:6})]})},{time:60,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:7})]})}]},{label:"process R",events:[{time:0,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:1})]})},{time:20,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:2})]})},{time:40,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:3})]})},{time:60,highlight:d[0],label:e(s,{children:[e(i,{children:"r"}),e(g,{value:4})]})}]}],messages:[{from:[0,0],to:[1,1]},{from:[1,0],to:[0,1]},{from:[1,4],to:[0,3]},{from:[1,0],to:[2,3]},{from:[1,3],to:[2,2]},{from:[2,1],to:[1,6]}],ticks:[[2,2,2],[7,7,7],[30,15,18],[42,18,24],[44,25,30],[50,35,38],[55,45,45],[65,55,55]]}),e("figcaption",{children:"Figure 2"})]}),e("p",{children:["We can consider the tick lines to be the time coordinate lines of some Cartesian coordinate system on space-time. We can redraw ",e(T,{id:f.figures.second,children:"Figure 2"})," to straighten these coordinate lines, thus obtaining ",e(T,{id:f.figures.third,children:"Figure 3"}),". ",e(T,{id:f.figures.third,children:"Figure 3"})," is a valid alternate way of representing the same system of events as ",e(T,{id:f.figures.second,children:"Figure 2"}),". Without introducing the concept of physical time into the system (which requires introducing physical clocks), there is no way to decide which of these pictures is a better representation."]}),e("figure",{id:f.figures.third,class:"space-time",children:[e(X,{width:150,height:150,path:y,processes:[{label:"process P",highlight:m[0],events:[{time:0,highlight:n[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:1})]})},{time:20,label:e(s,{children:[e(i,{children:"p"}),e(g,{value:2})]})},{time:30,highlight:c[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:3})]})},{time:70,highlight:l[0],label:e(s,{children:[e(i,{children:"p"}),e(g,{value:4})]})}]},{label:"process Q",highlight:v[0],events:[{time:0,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:1})]})},{time:20,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:2})]})},{time:40,highlight:h[0],label:e(s,{children:[e(i,{children:"q"}),e(g,{value:3})]})},{time:50,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:4})]})},{time:60,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:5})]})},{time:70,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:6})]})},{time:80,label:e(s,{children:[e(i,{children:"q"}),e(g,{value:7})]})}]},{label:"process R",events:[{time:0,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:1})]})},{time:30,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:2})]})},{time:60,label:e(s,{children:[e(i,{children:"r"}),e(g,{value:3})]})},{time:80,highlight:d[0],label:e(s,{children:[e(i,{children:"r"}),e(g,{value:4})]})}]}],messages:[{from:[0,0],to:[1,1]},{from:[1,0],to:[0,1]},{from:[1,4],to:[0,3]},{from:[1,0],to:[2,3]},{from:[1,3],to:[2,2]},{from:[2,1],to:[1,6]}],ticks:[[5,5,5],[15,15,15],[25,25,25],[35,35,35],[45,45,45],[55,55,55],[65,65,65],[75,75,75]]}),e("figcaption",{children:"Figure 3"})]}),e("p",{children:"The reader may find it helpful to visualize a two-dimensional spatial network of processes, which yields a three-dimensional space-time diagram. Processes and messages are still represented by lines, but tick lines become two-dimensional surfaces."}),e("p",{children:["Let us now assume that the processes are algorithms, and the events represent certain actions during their execution. We will show how to introduce clocks into the processes which satisfy the ",e(b,{children:["Clock Condition",e(p.Exit,{})]}),". Process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]}),"'s clock is represented by a register ",e(s,{description:"the clock register for the process",children:[e(i,{children:"C"}),e(i,{children:"i"})]}),", so that ",e(u,{description:"the logical timestamp of an event in the process",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"an event",children:"a"}),e(r,{children:o.operators.angle.right})]})," is the value contained by ",e(s,{description:"the clock register for the process",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," during the event ",e(i,{description:"an event in the process",children:"a"}),". The value of ",e(s,{description:"the clock register for the process",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," will change between events, so changing ",e(s,{description:"the clock register for the process",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," does not itself constitute an event."]}),e("p",{children:["To guarantee that the system of clocks satisfies the ",e(b,{children:["Clock Condition",e(p.Exit,{})]}),", we will insure that it satisfies conditions ",e(b,{children:["C1",e(C.Exit,{})]})," and ",e(b,{children:["C2",e(k.Exit,{})]}),". ",e(b,{children:["Condition C1",e(C.Exit,{})]})," is simple; the processes need only obey the following implementation rule:"]}),e("ol",{start:1,class:"implementation-rule",children:e("li",{id:f.implementation_rules.first,children:e(E.First.Entrance,{})})}),e("p",{children:["To meet ",e(b,{children:["condition C2",e(k.Exit,{})]}),", we require that each message ",e(i,{description:"a message",children:"m"})," contain a ",e("em",{children:"timestamp"})," ",e(s,{description:"the timestamp of the message",children:[e(i,{children:"T"}),e(i,{description:"a message",children:"m"})]})," which equals the time at which the message was sent. Upon receiving a message timestamped ",e(s,{description:"the timestamp of the message",children:[e(i,{children:"T"}),e(i,{description:"a message",children:"m"})]}),", a process must advance its clock to be later than ",e(s,{description:"the timestamp of the message",children:[e(i,{children:"T"}),e(i,{description:"a message",children:"m"})]}),". More precisely, we have the following rule."]}),e("ol",{start:2,class:"implementation-rule",children:e("li",{id:f.implementation_rules.second.root,children:e(E.Second.Root.Entrance,{})})}),e("p",{children:["In ",e(b,{children:["IR2(b)",e(E.Second.B.Exit,{})]})," we consider the event which represents the receipt of the message ",e(i,{description:"a message",children:"m"})," to occur after the setting of ",e(s,{description:"the receiving process's clock register",children:[e(i,{children:"C"}),e(i,{children:"j"})]}),". (This is just a notational nuisance, and is irrelevant in any actual implementation.) Obviously, ",e(b,{children:["IR2",e(E.Second.Root.Exit,{})]})," insures that ",e(b,{children:["C2",e(k.Exit,{})]})," is satisfied. Hence, the simple implementation rules ",e(b,{children:["IR1",e(E.First.Exit,{})]})," and ",e(b,{children:["IR2",e(E.Second.Root.Exit,{})]})," imply that the ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," is satisfied, so they guarantee a correct system of logical clocks."]})]}),e("section",{id:f.sections.total_ordering,children:[e("header",{children:"Ordering the Events Totally"}),e("p",{children:["We can use a system of clocks satisfying the ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," to place a total ordering on the set of all system events. We simply order the events by the times at which they occur. To break ties, we use any arbitrary total ordering ",e(r,{description:"an arbitrary total ordering",children:o.operators.precedes})," of the processes. More precisely, we define a relation ",e(r,{description:"totally happened before",children:o.operators.arrows.right.double})," as follows: if ",e(i,{description:"an event",children:"a"})," is an event in process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," and ",e(i,{description:"another event",children:"b"})," is an event in process ",e(s,{description:"another process",children:[e(i,{children:"P"}),e(i,{children:"j"})]}),", then ",e(u,{description:"the event totally happened before another event",children:[e(i,{description:"an event",children:"a"}),e(r,{description:"totally happened before",children:o.operators.arrows.right.double}),e(i,{description:"another event",children:"b"})]})," if and only if either"]}),e("ol",{type:"i",children:[e("li",{children:e("p",{children:[e(u,{description:"the logical timestamp of the first event is less than the logical timestamp of the second event",children:[e(u,{description:"the logical timestamp of the first event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the first event",children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.less_than}),e(u,{description:"the logical timestamp of the second event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:o.operators.angle.left}),e(i,{description:"the second event",children:"b"}),e(r,{children:o.operators.angle.right})]})]})," or"]})}),e("li",{children:e("p",{children:[e(u,{description:"the logical timestamps of the events are the same",children:[e(u,{description:"the logical timestamp of the first event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"a"}),e(r,{children:o.operators.angle.right})]}),e(r,{children:o.operators.equals}),e(u,{description:"the logical timestamp of the second event",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:o.operators.angle.left}),e(i,{children:"b"}),e(r,{children:o.operators.angle.right})]})]})," and ",e(u,{description:"the first process comes before the second process",children:[e(s,{description:"the first process",children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e(r,{description:"totally ordered before",children:o.operators.precedes}),e(s,{description:"the second process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})]}),"."]})})]}),e("p",{children:["It is easy to see that this defines a total ordering, and that the ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," implies that if ",e(u,{description:"an event happened before another event",children:[e(i,{description:"an event",children:"a"}),e(r,{description:"happened before",children:o.operators.arrows.right.single}),e(i,{description:"another event",children:"b"})]})," then ",e(u,{description:"the event totally happened before the other event",children:[e(i,{description:"the event",children:"a"}),e(r,{description:"totally happened event",children:o.operators.arrows.right.double}),e(i,{description:"the other event",children:"b"})]}),". In other words, the relation ",e(r,{description:"total-order happened before",children:o.operators.arrows.right.double}),' is a way of completing the "happened before" partial ordering to a total ordering. ',e(K,{portal:w.ordering})]}),e("p",{children:["The ordering ",e(r,{description:"total-order happened before relation",children:o.operators.arrows.right.double})," depends upon the system of clocks ",e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),", and is not unique. Different choices of clocks which satisfy the ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," yield different relations ",e(r,{description:"total-order happened before relation",children:o.operators.arrows.right.double}),". Given any total ordering relation ",e(r,{description:"total-order happened before relation",children:o.operators.arrows.right.double})," which extends ",e(r,{description:"happened before relation",children:o.operators.arrows.right.single}),", there is a system of clocks satisfying the ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," which yields that relation. It is only the partial ordering ",e(r,{description:"happened before relation",children:o.operators.arrows.right.single})," which is uniquely determined by the system of events."]}),e("p",{children:"Being able to totally order the events can be very useful in implementing a distributed system. In fact, the reason for implementing a correct system of logical clocks is to obtain such a total ordering. We will illustrate the use of this total ordering of events by solving the following version of the mutual exclusion problem. Consider a system composed of a fixed collection of processes which share a single resource. Only one process can use the resource at a time, so the processes must synchronize themselves to avoid conflict. We wish to find an algorithm for granting the resource to a process which satisfies the following three conditions:"}),e(S.Entrance,{}),e("p",{children:"We assume that the resource is initially granted to exactly one process."}),e("p",{children:["These are perfectly natural requirements. They precisely specify what it means for a solution to be correct. ",e(K,{portal:w.eventually})," Observe how the conditions involve the ordering of events. ",e(b,{children:["Condition II",e(q.Second.Exit,{})]})," says nothing about which of two concurrently issued requests should be granted first."]}),e("p",{children:["It is important to realize that this is a nontrivial problem. Using a central scheduling process which grants requests in the order they are received will not work, unless additional assumptions are made. To see this, let ",e(s,{description:"the scheduling process",children:[e(i,{children:"P"}),e(g,{value:0})]})," be the scheduling process. Suppose ",e(s,{description:"the first process",children:[e(i,{children:"P"}),e(g,{value:1})]})," sends a request to ",e(s,{description:"the scheduling process",children:[e(i,{children:"P"}),e(g,{value:0})]})," and then sends a message to ",e(s,{description:"the second process",children:[e(i,{children:"P"}),e(g,{value:2})]}),". Upon receiving the latter message, ",e(s,{description:"the second process",children:[e(i,{children:"P"}),e(g,{value:2})]})," sends a request to ",e(s,{description:"the scheduling process",children:[e(i,{children:"P"}),e(g,{value:0})]}),". It is possible for ",e(s,{description:"the second process",children:[e(i,{children:"P"}),e(g,{value:2})]}),"'s request to reach ",e(s,{description:"the scheduling process",children:[e(i,{children:"P"}),e(g,{value:0})]})," before ",e(s,{description:"the first process",children:[e(i,{children:"P"}),e(g,{value:1})]}),"'s request does. ",e(b,{children:["Condition II",e(q.Second.Exit,{})]})," is then violated if ",e(s,{description:"the second process",children:[e(i,{children:"P"}),e(g,{value:2})]}),"'s request is granted first."]}),e("p",{children:["To solve the problem, we implement a system of clocks with rules ",e(b,{children:["IR1",e(E.First.Exit,{})]})," and ",e(b,{children:["IR2",e(E.Second.Root.Exit,{})]}),", and use them to define a total ordering ",e(r,{description:"total-order happened before",children:o.operators.arrows.right.double})," of all events. This provides a total ordering of all request and release operations. With this ordering, finding a solution becomes a straightforward exercise. It just involves making sure that each process learns about all other processes' operations."]}),e("p",{children:["To simplify the problem, we make some assumptions. They are not essential, but they are introduced to avoid distracting implementation details. We assume first of all that any two processes ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," and ",e(s,{description:"another process",children:[e(i,{children:"P"}),e(i,{children:"j"})]}),", the messages sent from ",e(s,{description:"the process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," to ",e(s,{description:"another process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})," are received in the same order as they are sent. Moreover, we assume that every message is eventually received. (These assumptions can be avoided by introducing message numbers and message acknowledgement protocols.) We also assume that a process can send messages directly to every other process."]}),e("p",{children:["Each process maintains its own ",e("em",{children:"request queue"})," which is never seen by any other process. We assume that the request queues initially contain the single message ",e(u,{children:[e(s,{children:[e(i,{children:"T"}),e(g,{value:0})]}),e(r,{children:":"}),e(s,{children:[e(i,{children:"P"}),e(g,{value:0})]}),e("mtext",{children:" requests resource"})]}),", where ",e(s,{children:[e(i,{children:"P"}),e(g,{value:0})]})," is the process initially granted the resource and ",e(s,{children:[e(i,{children:"T"}),e(g,{value:0})]})," is less than the initial value of any clock."]}),e("p",{children:"The algorithm is then defined by the following five rules. For convenience, the actions defined by each rule are assumed to form a single event."}),e("ol",{children:[e("li",{children:e("p",{children:["To request the resource, process ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," sends the message ",e(u,{children:[e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]}),e(r,{children:":"}),e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"requests resource"})]})," to every other process, and puts that message on its request queue, where ",e(s,{children:[e(i,{children:"T"}),e(i,{children:"m"})]})," is the timestamp of the message."]})}),e("li",{id:f.mutual_exclusion.rules.second,children:e($.Second.Entrance,{})}),e("li",{id:f.mutual_exclusion.rules.third,children:e($.Third.Entrance,{})}),e("li",{id:f.mutual_exclusion.rules.fourth,children:e($.Fourth.Entrance,{})}),e("li",{id:f.mutual_exclusion.rules.fifth.root,children:e($.Fifth.Root.Entrance,{})})]}),e("p",{children:["Note that ",e(b,{children:["conditions (i) and (ii) of rule 5",e($.Fifth.Root.Exit,{})]})," are tested locally by ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),"."]}),e("p",{children:["It is easy to verify that the algorithm defined by these rules satisfies ",e(b,{children:["conditions I-III",e(S.Exit,{})]}),". First of all, observe that ",e(b,{children:["condition (ii) of rule 5",e($.Fifth.Second.Exit,{})]}),", together with the assumption that messages are received in order, guarantees that ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," has learned about all requests which preceded its current request. Since ",e(b,{children:["rules 3",e($.Third.Exit,{})]})," and ",e(b,{children:["4",e($.Fourth.Exit,{})]})," are the only ones which delete messages from the request queue, it is then easy to see that ",e(b,{children:["condition I",e(q.First.Exit,{})]})," holds. ",e(b,{children:["Condition II",e(q.Second.Exit,{})]})," follows from the fact that the total ordering ",e(r,{children:o.operators.arrows.right.double})," extends the partial ordering ",e(r,{children:o.operators.arrows.right.single}),". ",e(b,{children:["Rule 2",e($.Second.Exit,{})]})," guarantees that after ",e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]})," requests the resource, ",e(b,{children:["condition (ii) of rule 5",e($.Fifth.Second.Exit,{})]})," will eventually hold. ",e(b,{children:["Rules 3",e($.Third.Exit,{})]})," and ",e(b,{children:["4",e($.Fourth.Exit,{})]})," imply that if each process which is granted the resource eventually releases it, then ",e(b,{children:["condition (i) of rule 5",e($.Fifth.First.Exit,{})]})," will eventually hold, thus providing ",e(b,{children:["condition III",e(q.Third.Exit,{})]}),"."]}),e("p",{children:["This is a distributed algorithm. Each process independently follows these rules, and there is no central synchronizing process or central storage. This approach can be generalized to implement any desired synchronization for such a distributed multiprocess system. The synchronization is specified in terms of a State Machine, consisting of a set ",e(i,{children:"C"})," of possible commands, a set ",e(i,{children:"S"})," of possible states, and a function ",e(u,{children:[e(i,{children:"e"}),e(r,{children:":"}),e(i,{children:"C"}),e(r,{children:o.operators.cross}),e(i,{children:"S"}),e(r,{children:o.operators.arrows.right.single}),e(i,{children:"S"})]}),". The relation ",e(u,{children:[e(i,{children:"e"}),e(r,{children:"("}),e(i,{children:"C"}),e(r,{children:","}),e(i,{children:"S"}),e(r,{children:")"}),e(r,{children:o.operators.equals}),e(i,{children:"S"}),e(r,{children:o.operators.prime})]})," means that executing the command ",e(i,{children:"C"})," with the machine in state ",e(i,{children:"S"})," causes the machine state to change to ",e(u,{children:[e(i,{children:"S"}),e(r,{children:"prime"})]}),". In our example, the set ",e(i,{children:"C"})," consists of all the commands ",e(u,{children:[e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"requests resource"})]})," and ",e(u,{children:[e(s,{children:[e(i,{children:"P"}),e(i,{children:"i"})]}),e("mtext",{children:"releases resource"})]}),", and the state consists of a queue of waiting ",e("em",{children:"request"})," commands, where the request at the head of the queue is the currently granted one. Executing a ",e("em",{children:"request"})," command adds the request to the tail of the queue, and executing a ",e("em",{children:"release"})," command removes a command from the queue. ",e(K,{portal:w.release})]}),e("p",{children:["Each process independently simulates the execution of the State Machine, using the commands issued by all the processes. Synchronization is achieved because all processes order the commands according to their timestamps (using the relation ",e(r,{children:o.operators.arrows.right.double}),"), so each process uses the same sequence of commands. A process can execute a command timestamped ",e(i,{children:"T"})," when it has learned of all commands issued by all other processes with timestamps less than or equal to ",e(i,{children:"T"}),". The precise algorithm is straight-forward, and we will not bother to describe it."]}),e("p",{children:"This method allows one to implement any desired form of multiprocess synchronization in a distributed system. However, the resulting algorithm requires the active participation of all the processes. A process must know all the commands issued by other processes, so that the failure of a single process will make it impossible for any other process to execute State Machine commands, thereby halting the system."}),e("p",{children:['The problem of failure is a difficult one, and it is beyond the scope of this paper to discuss it in any detail. We will just observe that the entire concept of failure is only meaningful in the context of physical time. Without physical time, there is no way to distinguish a failed process from one which is just pausing between events. A user can tell that a system has "crashed" only because he has been waiting too long for a response. A method which works despite the failure of individual processes or communication lines is described in ',e(pe,{href:f.references.lamport_implementation,children:"[3]"}),"."]})]}),e("section",{id:f.sections.anomalous_behavior,children:[e("header",{children:"Anomalous Behavior"}),e("p",{children:["Our resource scheduling algorithm ordered the requests according to the total ordering ",e(r,{description:"total-order happened before",children:o.operators.arrows.right.double}),'. This permits the following type of "anomalous behavior." Consider a nationwide system of interconnected computers. Suppose a person issues a request ',e(i,{description:"a request on computer A",children:o.letters.capital.a.monospace})," on a computer A, and then telephones a friend in another city to have him issue a request ",e(i,{description:"a request on computer B",children:o.letters.capital.b.monospace})," on a different computer B. It is quite possible for request ",e(i,{description:"the request from computer B",children:o.letters.capital.b.monospace})," to receive a lower timestamp and be ordered before request ",e(i,{description:"the request from computer A",children:o.letters.capital.a.monospace}),". This can happen because the system has no way of knowing that ",e(i,{description:"the request from computer A",children:o.letters.capital.a.monospace})," actually preceded ",e(i,{description:"the request from computer B",children:o.letters.capital.b.monospace}),", since that precedence information is based on messages external to the system."]}),e("p",{children:["Let us examine the source of the problem more closely. Let ",e(i,{description:"the set of all system events",children:o.greek.zeta})," be the set of all system events. Let us introduce a set of events which contains the events in ",e(i,{description:"the set of all system events",children:o.greek.zeta})," together with all other relevant external events, such as the phone calls in our example. Let ",e(r,{children:o.operators.arrows.right.thick}),' denote the "happened before" relation for ',e(i,{description:"the set of all system events",children:o.greek.zeta}),". In our example, we had ",e(u,{children:[e(i,{children:o.letters.capital.a.monospace}),e(r,{children:o.operators.arrows.right.thick}),e(i,{children:o.letters.capital.b.monospace})]}),", but ",e(u,{children:[e(i,{children:o.letters.capital.a.monospace}),e(r,{children:o.operators.arrows.right.not_single}),e(i,{children:o.letters.capital.b.monospace})]}),". It is obvious that no algorithm based entirely upon events in ",e(i,{description:"the set of all system events",children:o.greek.zeta}),", and which does not relate those events in any way with the other events in ",e(i,{description:"the set of all system events",children:o.greek.zeta}),", can guarantee that request ",e(i,{children:o.letters.capital.a.monospace})," is ordered before request ",e(i,{children:o.letters.capital.b.monospace}),"."]}),e("p",{children:["There are two possible ways to avoid such anomalous behavior. The first way is to explicitly introduce into the system the necessary information about the ordering ",e(r,{children:o.operators.arrows.right.thick}),". In our example, the person issuing request ",e(i,{description:"the request from computer A",children:o.letters.capital.a.monospace})," could receive the timestamp ",e(s,{description:"the timestamp of the request from computer A",children:[e(i,{children:"T"}),e(i,{description:"the request from computer A",children:o.letters.capital.a.monospace})]})," of that request from the system. When issuing request ",e(i,{description:"the request from computer B",children:o.letters.capital.b.monospace}),", his friend could specify that ",e(i,{description:"the request from computer B",children:o.letters.capital.b.monospace})," be given a timestamp later than ",e(s,{description:"the timestamp of the request from computer A",children:[e(i,{children:"T"}),e(i,{description:"the request from computer A",children:o.letters.capital.a.monospace})]}),". This gives the user the responsibility for avoiding anomalous behavior."]}),e("p",{children:"The second approach is to construct a system of clocks which satisfies the following condition."}),e(P.Entrance,{}),e("p",{children:["This is stronger than the ordinary ",e(b,{children:["Clock Condition",e(p.Exit,{})]})," because ",e(r,{children:o.operators.arrows.right.thick})," is a stronger relation than ",e(r,{description:"happened before",children:o.operators.arrows.right.single}),". It is not in general satisfied by our logical clocks."]}),e("p",{children:["Let us identify ",e(i,{children:o.greek.zeta}),' with some set of "real" events in physical space-time, and let ',e(r,{children:o.operators.arrows.right.thick})," be the partial ordering of events defined by special relativity. One of the mysteries of the universe is that it is possible to construct a system of physical clocks which, running quite independently of one another, will satisfy the ",e(b,{children:["Strong Clock Condition.",e(P.Exit,{})]})," We can therefore use physical clocks to eliminate anomalous behavior. We now turn our attention to such clocks."]})]}),e("section",{id:f.sections.physical_clocks,children:[e("header",{children:"Physical Clocks"}),e("p",{children:["Let us introduce a physical time coordinate into our space-time picture, and let ",e(u,{children:[e(s,{description:"a clock function",children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.paren.left}),e(i,{description:"physical time",children:"t"}),e(r,{children:o.operators.paren.right})]})," denote the reading of the clock ",e(s,{description:"a clock",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," at physical time ",e(i,{description:"physical time",children:"t"}),". ",e(K,{portal:w.time}),' For mathematical convenience, we assume that the clocks run continuously rather than in discrete "ticks." (A discrete clock can be thought of as a continuous one in which there is an error of up to ',e(ne,{children:[e(g,{value:1}),e(g,{value:2})]}),' "tick" in reading it.) More precisely, we assume that ',e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.paren.left}),e(i,{description:"physical time",children:"t"}),e(r,{children:o.operators.paren.right})]})," is a continuous, differentiable function of ",e(i,{description:"physical time",children:"t"})," except for isolated jump discontinuities where the clock is reset. Then ",e(ne,{children:[e(u,{children:[e(r,{children:"d"}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:o.operators.paren.left}),e(i,{description:"physical time",children:"t"}),e(r,{children:o.operators.paren.right})]}),e(r,{children:"dt"})]})," represents the rate at which the clock is running at time ",e(i,{children:"t"}),"."]}),e("p",{children:["In order for the clock ",e(s,{description:"a clock",children:[e(i,{children:"C"}),e(i,{children:"i"})]})," to be a true physical clock, it must run at approximately the correct rate. That is, we must have ",e(u,{description:"the rate at which the clock is running is approximately equal to 1 tick per second",children:[e(ne,{children:[e(u,{children:[e(r,{children:"d"}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:"dt"})]}),e(r,{children:o.operators.approx}),e(g,{value:1})]})," for all ",e(i,{description:"physical time",children:"t"}),". More precisely, we will assume that the following condition is satisfied:"]}),e("ol",{class:"physical-clock",children:e("li",{children:e(F.Entrance,{})})}),e("p",{children:["For typical crystal controlled clocks, ",e(u,{children:[e(i,{description:"maximum clock speed error",children:o.greek.kappa}),e(r,{children:o.operators.less_than_equal}),e(Ei,{children:[e(g,{value:10}),e(g,{value:-6})]})]}),"."]}),e("p",{children:["It is not enough for the clocks individually to run at approximately the correct rate. They must be synchronized so that ",e(u,{description:"one clock is approximately the same as another clock",children:[e(u,{description:"one clock",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{description:"physical time",children:"t"}),e(r,{children:")"})]}),e(r,{children:o.operators.approx}),e(u,{description:"another clock",children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{description:"physical time",children:"t"}),e(r,{children:")"})]})]})," for all ",e(i,{children:"i"}),", ",e(i,{children:"j"}),", and ",e(i,{children:"t"}),". More precisely, there must be a sufficiently small constant ",e(i,{description:"maximum clock drift",children:o.greek.epsilon})," so that the following condition holds:"]}),e("ol",{start:2,class:"physical-clock",children:e("li",{children:e(I.Entrance,{})})}),e("p",{children:["If we consider vertical distance in ",e(T,{id:f.figures.second,children:"Figure 2"})," to represent physical time, then ",e(b,{children:["PC2",e(I.Exit,{})]})," states that the variation in height of a single tick line is less than ",e(i,{description:"maximum clock drift",children:o.greek.epsilon}),"."]}),e("p",{children:["Since two different clocks will never run at exactly the same rate, they will tend to drift further and further apart. We must therefore devise an algorithm to insure that ",e(b,{children:["PC2",e(I.Exit,{})]})," always holds. First, however, let us examine how small ",e(i,{description:"maximum clock speed error",children:o.greek.kappa})," and ",e(i,{description:"maximum clock drift",children:o.greek.epsilon})," must be to prevent anomalous behavior. We must insure that the system ",e(i,{children:o.greek.zeta})," of relevant physical events satisfies the ",e(b,{children:["Strong Clock Condition",e(P.Exit,{})]}),". We assume that our clocks satisfy the ordinary ",e(b,{children:["Clock Condition",e(p.Exit,{})]}),", so we need only require that the ",e(b,{children:["Strong Clock Condition",e(P.Exit,{})]})," holds when ",e(i,{description:"an event",children:"a"})," and ",e(i,{description:"another event",children:"b"})," are events in ",e(i,{children:o.greek.zeta})," with ",e(u,{description:"the event did not happen before the other event",children:[e(i,{description:"the event",children:"a"}),e(r,{description:"did not happen before",children:o.operators.arrows.right.not_single}),e(i,{description:"another event",children:"b"})]}),". Hence, we need only consider events occurring in different processes."]}),e("p",{children:["Let ",e(i,{children:o.greek.mu})," be a number such that if event ",e(i,{children:"a"})," occurs at physical time ",e(i,{children:"t"})," and event ",e(i,{children:"b"})," in another process satisfies ",e(u,{children:[e(i,{children:"a"}),e(r,{children:o.operators.arrows.right.thick}),e(i,{children:"b"})]}),", then ",e(i,{children:"b"})," occurs later than physical time ",e(u,{children:[e(i,{children:"t"}),e(r,{children:"+"}),e(i,{children:o.greek.mu})]}),". In other words, ",e(i,{children:o.greek.mu})," is less than the shortest transmission time for interprocess messages. We can always choose ",e(i,{children:o.greek.mu})," equal to the shortest distance between processes divided by the speed of light. However, depending upon how messages in ",e(i,{children:o.greek.zeta})," are transmitted, ",e(i,{children:o.greek.mu})," could be significantly larger."]}),e("p",{children:["To avoid anomalous behavior, we must make sure that for any ",e(i,{children:"i"}),", ",e(i,{children:"j"}),", and ",e(i,{children:"t"}),": ",e(u,{children:[e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:"+"}),e(i,{children:o.greek.mu}),e(r,{children:")"})]}),e(r,{children:"-"}),e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:o.operators.greater_than}),e(g,{value:0})]}),". Combining this with ",e(b,{children:["PC1",e(F.Exit,{})]})," and ",e(b,{children:["2",e(I.Exit,{})]})," allows us to relate the required smallness of ",e(i,{children:o.greek.kappa})," and ",e(i,{children:o.greek.epsilon})," to the value of ",e(i,{children:o.greek.mu})," as follows. We assume that when a clock is reset, it is always set forward and never back. (Setting it back would cause ",e(b,{children:["C1",e(C.Exit,{})]})," to be violated.) ",e(b,{children:["PC1",e(F.Exit,{})]})," then implies that ",e(u,{children:[e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:"+"}),e(i,{children:o.greek.mu}),e(r,{children:")"})]}),e(r,{children:"-"}),e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:o.operators.greater_than}),e(u,{children:[e(r,{children:"("}),e(g,{value:1}),e(r,{children:"-"}),e(i,{children:o.greek.kappa}),e(r,{children:")"}),e(i,{children:o.greek.mu})]})]}),". Using ",e(b,{children:["PC2",e(I.Exit,{})]}),", it is then easy to deduce that ",e(u,{children:[e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:"+"}),e(i,{children:o.greek.mu}),e(r,{children:")"})]}),e(r,{children:"-"}),e(u,{children:[e(s,{children:[e(i,{children:"C"}),e(i,{children:"j"})]}),e(r,{children:"("}),e(i,{children:"t"}),e(r,{children:")"})]}),e(r,{children:o.operators.greater_than}),e(g,{value:0})]})," if the following inequality holds: ",e(u,{display:"block",children:[e(ne,{children:[e(i,{children:o.greek.epsilon}),e(u,{children:[e(r,{children:"("}),e(g,{value:1}),e(r,{children:"-"}),e(i,{children:o.greek.kappa}),e(r,{children:")"})]})]}),e(r,{children:o.operators.less_than_equal}),e(i,{children:o.greek.mu})]}),"This inequality together with ",e(b,{children:["PC1",e(F.Exit,{})]})," and ",e(b,{children:["PC2",e(I.Exit,{})]})," implies that anomalous behavior is impossible."]}),e("p",{children:["We now describe our algorithm for insuring that ",e(b,{children:["PC2",e(I.Exit,{})]})," holds. Let ",e(i,{description:"a message",children:"m"})," be a message which is sent at physical time ",e(i,{description:"physical time",children:"t"})," and received at time ",e(u,{children:[e(i,{description:"physical time",children:"t"}),e(r,{children:o.operators.prime})]}),". We define ",e(u,{children:[e(s,{description:"the total delay of the message",children:[e(i,{children:"v"}),e(i,{children:"m"})]}),e(r,{children:"="}),e(u,{description:"received time",children:[e(i,{children:"t"}),e(r,{children:o.operators.prime})]}),e(r,{children:"-"}),e(i,{description:"sent time",children:"t"})]})," to be the ",e("em",{children:"total delay"})," of the message ",e(i,{children:"m"}),". This delay will, of course, not be known to the process which receives ",e(i,{children:"m"}),". However, we assume that the receiving process knows some ",e("em",{children:"minimum delay"})," ",e(u,{children:[e(s,{description:"minimum delay of a message",children:[e(i,{children:o.greek.mu}),e(i,{children:"m"})]}),e(r,{children:o.operators.greater_than_equal}),e(g,{value:0})]})," such that ",e(u,{description:"the minimum delay of a message is less than the total delay of the message",children:[e(s,{description:"minimum delay of a message",children:[e(i,{children:o.greek.mu}),e(i,{children:"m"})]}),e(r,{children:o.operators.less_than_equal}),e(s,{description:"total delay of a message",children:[e(i,{children:"v"}),e(i,{children:"m"})]})]}),". We call ",e(u,{children:[e(s,{description:"the unpredictable delay of a message",children:[e(i,{children:o.greek.xi}),e(i,{children:"m"})]}),e(r,{children:"="}),e(s,{description:"the total delay of a message",children:[e(i,{children:"v"}),e(i,{children:"m"})]}),e(r,{children:"-"}),e(s,{description:"the minimum delay of a message",children:[e(i,{children:o.greek.mu}),e(i,{children:"m"})]})]})," the ",e("em",{children:"unpredictable delay"})," of the message."]}),e("p",{children:["We now specialize rules ",e(b,{children:["IR1",e(E.First.Exit,{})]})," and ",e(b,{children:["2",e(E.Second.Root.Exit,{})]})," for our physical clocks as follows:"]}),e("ol",{id:"physical-implementation-rules",children:[e("li",{id:f.physical_implementation_rules.first,children:e(W.First.Entrance,{})}),e("li",{id:f.physical_implementation_rules.second,children:e(W.Second.Entrance,{})})]}),e("p",{children:["Although the rules are formally specified in terms of the physical time parameter, a process only needs to know its own clock reading and the timestamps of messages it receives. For mathematical convenience, we are assuming that each event occurs at a precise instant of physical time, and different events in the same process occur at different times. These rules are then specializations of rules ",e(b,{children:["IR1",e(E.First.Exit,{})]})," and ",e(b,{children:["IR2",e(E.Second.Root.Exit,{})]}),", so our system of clocks satisfies the ",e(b,{children:["Clock Condition",e(p.Exit,{})]}),". The fact that real events have a finite duration causes no difficulty in implementing the algorithm. The only real concern in the implementation is making sure that the discrete clock ticks are frequent enough so ",e(b,{children:["C1",e(C.Exit,{})]})," is maintained."]}),e("p",{children:["We now show that this clock synchronizing algorithm can be used to satisfy ",e(b,{children:["condition PC2",e(I.Exit,{})]}),". We assume that the system of processes is described by a directed graph in which an arc from process ",e(s,{description:"a process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," to process ",e(s,{description:"a neighbour process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})," represents a communication line over which messages are sent directly from ",e(s,{description:"the process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," to ",e(s,{description:"the neighbour process",children:[e(i,{children:"P"}),e(i,{children:"j"})]}),". We say that a message is sent over this arc every ",e(i,{description:"neighbour period",children:o.greek.tau})," seconds if for any ",e(i,{description:"physical time",children:"t"}),", ",e(s,{description:"the process",children:[e(i,{children:"P"}),e(i,{children:"i"})]})," sends at least one message to ",e(s,{description:"the neighbour process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})," between physical times ",e(i,{description:"physical time",children:"t"})," and ",e(u,{children:[e(i,{description:"physical time",children:"t"}),e(r,{children:"+"}),e(i,{description:"neighbour period",children:o.greek.tau})]}),". The ",e("em",{children:"diameter"})," of the directed graph is the smallest number ",e(i,{description:"diameter",children:"d"})," such that for any pair of distinct processes ",e(s,{description:"the start process",children:[e(i,{children:"P"}),e(i,{children:"j"})]}),", ",e(s,{description:"the target process",children:[e(i,{children:"P"}),e(i,{children:"k"})]}),", there is a path from ",e(s,{description:"the start process",children:[e(i,{children:"P"}),e(i,{children:"j"})]})," to ",e(s,{description:"the target process",children:[e(i,{children:"P"}),e(i,{children:"k"})]})," having at most ",e(i,{description:"diameter",children:"d"})," arcs."]}),e("p",{children:["In addition to establishing ",e(b,{children:["PC2",e(I.Exit,{})]}),", the following theorem bounds the length of time it can take the clocks to become synchronized when the system is first started."]}),e("section",{children:[e("p",{children:[e("strong",{children:"THEOREM"}),". Assume a strongly connected graph of processes with diameter ",e(i,{description:"diameter",children:"d"})," which always obeys rules ",e(b,{children:["IR1'",e(W.First.Exit,{})]})," and ",e(b,{children:["IR2'",e(W.Second.Exit,{})]}),". Assume that for any message ",e(i,{description:"a message",children:"m"}),", ",e(u,{children:[e(s,{description:"the message's minimum delay",children:[e(i,{children:o.greek.mu}),e(i,{children:"m"})]}),e(r,{children:o.operators.less_than_equal}),e(i,{description:"maximum message delay",children:o.greek.mu})]})," for some constant ",e(i,{description:"maximum message delay",children:o.greek.mu}),", and that for all ",e(u,{children:[e(i,{description:"physical time",children:"t"}),e(r,{children:o.operators.greater_than_equal}),e(s,{description:"initial physical time?",children:[e(i,{children:"t"}),e(g,{value:0})]})]}),":"]}),e("ol",{type:"a",children:[e("li",{children:e("p",{children:"PC1 holds."})}),e("li",{children:e("p",{children:["There are constants ",e(i,{description:"neighbour period",children:o.greek.tau})," and ",e(i,{description:"maximum unpredictable delay",children:o.greek.xi})," such that every ",e(i,{description:"neighbour period",children:o.greek.tau})," seconds a message with an unpredictable delay less than ",e(i,{description:"maximum unpredictable delay",children:o.greek.xi})," is sent over every arc."]})})]}),e("p",{children:["Then PC2 is satisfied with ",e(u,{children:[e(i,{description:"maximum clock drift",children:o.greek.epsilon}),e(r,{children:o.operators.approx}),e(i,{description:"diameter",children:"d"}),e(r,{children:"("}),e(g,{value:2}),e(i,{description:"maximum clock speed error",children:o.greek.kappa}),e(i,{description:"neighbour period",children:o.greek.tau}),e(r,{children:"+"}),e(i,{description:"maximum unpredictable delay",children:o.greek.xi}),e(r,{children:")"})]})," for all ",e(u,{children:[e(i,{description:"physical time",children:"t"}),e(r,{children:o.operators.greater_than_equal}),e(s,{description:"initial physical time",children:[e(i,{children:"t"}),e(g,{value:0})]}),e(r,{children:"+"}),e(i,{description:"neighbour period",children:o.greek.tau}),e(i,{description:"diameter",children:"d"})]}),", where the approximations assume ",e(u,{children:[e(i,{description:"maximum message delay",children:o.greek.mu}),e(r,{children:"+"}),e(i,{description:"maximum unpredictable delay",children:o.greek.xi}),e(r,{children:o.operators.much_less_than}),e(i,{description:"neighbour period",children:o.greek.tau})]}),"."]})]}),e("p",{children:["The proof of this theorem is surprisingly difficult, and is given in the Appendix. There has been a great deal of work done on the problem of synchronizing physical clocks. We refer the reader to ",e(pe,{href:f.references.system_time,children:"[4]"})," for an introduction to the subject. The methods describe in the literature are useful for estimating the message delays ",e(s,{description:"minimum message delay",children:[e(i,{children:o.greek.mu}),e(i,{children:"m"})]})," and for adjusting the clock frequencies ",e(ne,{description:"a clock's frequency",children:[e(u,{children:[e(r,{children:"d"}),e(s,{children:[e(i,{children:"C"}),e(i,{children:"i"})]})]}),e(r,{children:"dt"})]})," (for clocks which permit such an adjustment). However, the requirement that clocks are never set backwards seems to distinguish our situation from ones previously studied, and we believe this theorem to be a new result."]})]}),e("section",{id:f.sections.conclusion,children:[e("header",{children:"Conclusion"}),e("p",{children:'We have seen that the concept of "happening before" defines an invariant partial ordering of the events in a distributed multiprocess system. We described an algorithm for extending that partial ordering to a somewhat arbitrary total ordering, and showed how this total ordering can be used to solve a simple synchronization problem. A future paper will show how this approach can be extended to solve any synchronization problem.'}),e("p",{children:"The total ordering defined by the algorithm is somewhat arbitrary. It can produce anomalous behavior if it disagrees with the ordering perceived by the system's users. This can be prevented by the use of properly synchronized physical clocks. Our theorem showed how closely the clocks can be synchronized."}),e("p",{children:"In a distributed system, it is important to realize that the order in which events occur is only a partial ordering. We believe that this idea is useful in understanding any multiprocess system. It should help one to understand the basic problems of multiprocessing independently of the mechanisms used to solve them."})]}),e("section",{id:f.sections.appendix,children:[e("header",{children:"Appendix"}),e("p",{children:"See the paper for details."}),e("p",{children:[e("em",{children:"Acknowledgement."})," The use of timestamps to order operations, and the concept of anomalous behavior are due to Paul Johnson and Robert Thomas."]})]}),e("section",{id:f.sections.notes,children:[e("header",{children:"Notes"}),e("ol",{children:[e("li",{id:f.notes.event,children:e(w.event.Entrance,{})}),e("li",{id:f.notes.message,children:e(w.message.Entrance,{})}),e("li",{id:f.notes.ordering,children:e(w.ordering.Entrance,{})}),e("li",{id:f.notes.eventually,children:e(w.ordering.Entrance,{})}),e("li",{id:f.notes.acknowledgement,children:e(w.acknowledgement.Entrance,{})}),e("li",{id:f.notes.receive_message,children:e(w.receive_message.Entrance,{})}),e("li",{id:f.notes.release,children:e(w.release.Entrance,{})}),e("li",{id:f.notes.time,children:e(w.time.Entrance,{})}),e("li",{id:f.notes.limit,children:e(w.limit.Entrance,{})})]})]}),e("section",{id:f.sections.references,children:[e("header",{children:"References"}),e("ol",{class:"reference",children:[e("li",{id:f.references.relativity,children:e("section",{class:"reference",children:[e("span",{class:"name",children:"Schwartz, J.T."}),e("span",{class:"title",children:"Relativity in Illustrations"}),e("span",{class:"publisher",children:"New York U. Press, New York"}),e("span",{class:"year",children:"1962"})]})}),e("li",{id:f.references.space_time,children:e("section",{class:"reference",children:[e("span",{class:"name",children:"Taylor, E.F."}),e("span",{class:"name",children:"Wheeler, J.A."}),e("span",{class:"title",children:"Space-Time Physics"}),e("span",{class:"publisher",children:"W.H. Freeman, San Francisco"}),e("span",{class:"year",children:"1966"})]})}),e("li",{id:f.references.lamport_implementation,children:e("section",{class:"reference",children:[e("span",{class:"name",children:"Lamport, L."}),e("span",{class:"title",children:"The implementation of reliable distributed multiprocess systems"}),e("span",{class:"publisher",children:"To appear in Computer Networks"})]})}),e("li",{id:f.references.system_time,children:e("section",{class:"reference",children:[e("span",{class:"name",children:"Ellingson, C."}),e("span",{class:"name",children:"Kulpinski, R.J."}),e("span",{class:"title",children:"Dissemination of system-time"}),e("span",{class:"publisher",children:"IEEE Trans. Comm"}),e("span",{children:"Com-23, 5 (May 1973), 605-624"})]})})]})]})]})}yi(e(Ai,{}),document.getElementById("root"));
